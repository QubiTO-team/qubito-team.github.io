[{"content":" Introduction to Qiskit # This is the first article in a series about Qiskit and will start from the very basics. Despite there are many similar videos and articles online, the goal of this lecture is to give new students a first hands-on approach to the topic with - hopefully - a good balance between details and ease for a beginner. After this lecture you should be able to start creating and simulating circuits in Qiskit.\nPreliminary concepts # In case you are not familiar with quantum circuits and gates, I suggest you have a look at IBM Quantum Composer, Quirk quantum circuit simulator and Bloch sphere simulator. These tools are a great way to familiarize with the quantum world using a graphical interface.\nFirst steps with Qiskit # Before writing code on our own, we can try running the code that in the composer to confirm that what we were seeing was actual Qiskit code. Look in the right panel of the composer and you should see some python code similarly to the following image (you may need to select \u0026ldquo;Qiskit\u0026rdquo; from the drop down menu if \u0026ldquo;OpenQASM 2.0\u0026rdquo; is already selected).\nIf you don\u0026rsquo;t what do open the composer just for this test, you can try running this code\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from numpy import pi qreg_q = QuantumRegister(2, \u0026#39;q\u0026#39;) creg_c = ClassicalRegister(2, \u0026#39;c\u0026#39;) circuit = QuantumCircuit(qreg_q, creg_c) circuit.h(qreg_q[0]) circuit.cx(qreg_q[0], qreg_q[1]) circuit.measure(qreg_q[0], creg_c[0]) circuit.measure(qreg_q[1], creg_c[1]) If everything worked, Jupyter should output something similar to this:\n\u0026lt;qiskit.circuit.instructionset.InstructionSet at 0x7f84d02584c0\u0026gt; This is a first step, but we would like to see something a bit nicer, like the drawing of the circuit!\nBefore seeing how to draw circuits, let\u0026rsquo;s briefly analyze the code above:\nThe first two lines with the from ... import ... are used to import python libraries which contain the functions and classes needed in the following. You don\u0026rsquo;t have to worry too much about the details for now, just remember to include what\u0026rsquo;s needed before running the code.\nAfter this we start with the creation of the circuit itself, as a first step we create one quantum and one classical register. Registers are collections of bits or qubits, if you don\u0026rsquo;t have experience with classical computers you can see them as a way to group (q)bits that have a similar meaning. To give an example, if you are trying to create a circuit that sums two 3-digit numbers A and B, you could create a register regA with three bits to store the digits of A and do the same for B; in this way it is easier to remember what is what. Although registers are useful when creating complex circuits, they can create confusion with very simple circuits as the one in this article; for this reason I will not use them much later. I will only show them in this example since they are used by default in the composer.\nThe important thing to remember is that a QuantumRegister is an array of qubits, so writing qreg_q[0] means \u0026ldquo;taking the first qubit in quantum register qreg_q\u0026rdquo;.\nNow we can proceed creating a quantum circuit named circuit that contains 2 qubits (the ones in qreg_q) and 2 bits (the ones from creg_c).\nIf we want to start adding gates and operations to the circuit we can use the syntax shown in the following lines. In this example we apply a Hadamard gate (h) to the first qubit and then a CNOT gate (cx) that is controlled by the first qubit and has as a target the second qubit.\nFinally we measure the two qubits saving the results in the respective classical bits.\nDrawing a circuit # Now that we have an idea of what the code above does, we want to see what it looks like in reality. This is very simple to do: just add the following line to the code and run it again.\ncircuit.draw(output=\u0026#34;mpl\u0026#34;) # Possible output formats: None, mpl, latex You should see an image like this one, which is exactly what was shown in the composer!\nNote that you may get an error if you don\u0026rsquo;t have some required library. If you do, try installing the libraries specified in the output or try removing output=\u0026quot;mpl\u0026quot;, the result will not be so fancy but it should work out of the box. If you have more doubts you can refer to the documentation.\nHow to deal with more complex circuits and gates # With what we saw before, you should be able to create basic circuits but it will soon become difficult to create advanced algorithms without introducing a couple more concepts. As an example, we would like to solve a simple problem:\nHow can we create an OR gate in a quantum circuit?\nThis question may seem silly at first: why should we care about creating a classical gate on a quantum circuit? For the time being it is not too important and it can be seen just as an exercise, but if you are curious you can look into oracles for the Grover algorithm; to implement them classical gates are extremely useful!\nAnother question that may arise is: why do we want to create the OR and not the AND? Well, because we already have the quantum version of the AND gate, it is called Toffoli gate or controlled-controlled-not (ccx in Qiskit).\nThis is what the Toffoli gate and its truth table look like:\nFirst of all we notice that this gate operates on 3 qubits and not on 2 as we would expect, the reason for this is not simple, for completing the exercise you should just keep in mind that the Toffoli behaves exactly as an AND gate when in input we have $ C = |0\\rangle $, the result of the AND will be found in $ C $ after the application of the gate.\nYou can verify this statement by seeing that if you ignore the rows where $ C = |1\\rangle $, the truth table of the Toffoli becomes identical as the one of the AND.\nThe reason why the \u0026ldquo;quantum AND\u0026rdquo; needs 3 qubits is that all quantum gates must be reversible, which means that, given any output of the gate, it must be possible to uniquely identify the input that generated it. As an example, look at the truth table of the AND gate: if you tell me that the output of the AND is $ 0 $, I wouldn\u0026rsquo;t be able to know if the input was 00, 01 or 10.\nA B A and B A or B 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 Let\u0026rsquo;s go back to the original question of creating the OR gate, we saw that we already have the AND, but what do we do with this information? Before \u0026ldquo;invoking\u0026rdquo; theorems, let\u0026rsquo;s do a couple of simple logical steps and see where we end up:\nLet\u0026rsquo;s try completing the following truth table where the inputs have been \u0026ldquo;flipped\u0026rdquo;:\nnot A not B (not A) and (not B) not( (not A) and (not B) ) 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 1 This seems an arbitrary choice of operations but if we look at the last column we can easily see that this is the same as the \u0026ldquo;OR\u0026rdquo; column of the first table, meaning that we created the \u0026ldquo;OR\u0026rdquo; function using only ANDs and NOTs! We could also do this formally using the De Morgan\u0026rsquo;s law.\nNow we have all the ingredients to move on and create our first custom gate! But first let\u0026rsquo;s recap the steps:\nWe want to create the OR gate using Qiskit by starting with the AND (Toffoli) gate and the NOT (X) gate. In Qiskit we already have these gates in the form of the ccx and x gates. Using the De Morgan\u0026rsquo;s law (or the simple steps above), we have proved that the following equivalence\nA | B = !(!A \u0026amp; !B)\nor, if you prefer a different notation\n$$ A \\lor B \\equiv \\lnot (\\lnot A \\land \\lnot B) $$\nLet\u0026rsquo;s now see how to convert this formula into a quantum circuit: first of all let\u0026rsquo;s point out that quantum circuits and gates, in Qiskit, can be used interchangeably, this means that we can create a quantum circuit as we did before and, later, use it as a single gate. We will see later how to do this, for the moment let\u0026rsquo;s focus on creating a circuit that implements the OR gate, using the formula above.\nTo begin with, we need a circuit with three qubits, A and B which are the inputs and C which will contain the output.\nqc = QuantumCircuit(3) Notice how, in this case, I did not use any register but simply specified the number of qubits in the parameters of QuantumCircuit, let\u0026rsquo;s keep in mind that the first qubit (i.e. qc[0]) represents A, the second represents B and the third C.\nNow it\u0026rsquo;s just a matter of seeing which gate is applied to which qubit, in the formula we see that we have x gates applied to both A and B, so we can add them in python as follows:\nqc.x(0) qc.x(1) Then we have the AND between A and B; remember, the Toffoli (ccx) gate behaves as an AND when C (the target) is initially set to $|0\\rangle$, so we can add this gate as follows:\nqc.ccx(0, 1, 2) Finally we have to negate the output (the first NOT in the formula), since C is the output, we simply need to add an x gate to the third qubit:\nqc.x(2) It seems like we are done, let\u0026rsquo;s see what the resulting circuit looks like at this point:\nThis circuit gives the correct results but has an important problem: it changes the values of its inputs! Look at the first 2 qubits, they are subject to an x gate and so their value at the beginning is different from the one at the end. This is something we don\u0026rsquo;t want as it stops us from using the original A and B again.\nLuckily solving the issue is very simple, we just need to apply the inverse operation of the x gate which is\u0026hellip; the x gate itself! (Negating a given quantity twice is the same as doing nothing or, more formally $X \\cdot X = \\mathbb{I}$)\nSo let\u0026rsquo;s fix this problem:\nqc.x(0) qc.x(1) The final circuit for the OR is then:\nTo make the code we wrote easier to use in the following (and to create a real gate), let\u0026rsquo;s put everything inside a function that returns the circuit itself:\ndef OR() -\u0026gt; QuantumCircuit: qc = QuantumCircuit(3) qc.barrier() qc.x(0) qc.x(1) qc.ccx(0, 1, 2) qc.x(0) qc.x(1) qc.x(2) qc.barrier() return qc In this way, when we will need to use the OR gate in Qiskit, we will simply have to call this function.\nNotice that I also added two barriers at the beginning and end of the gate, barriers are not gates but are simply \u0026ldquo;vertical lines\u0026rdquo; that make it easier to visually delimit things when drawing the circuit (see the drawing above).\nIf you are wondering about the -\u0026gt; QuantumCircuit in the first line, it specifies the type of the object which will be returned by the function, it is not mandatory (as a matter of fact if you don\u0026rsquo;t put it nothing will change when running the code) but it allows your IDE (e.g. VSCode) to give you helpful autocompletion.\nComposing circuits # If we want to use this new gate we created inside a bigger circuit, we cannot simply write circuit.OR because this is not a \u0026ldquo;native\u0026rdquo; Qiskit gate, what we have to do is \u0026ldquo;attach\u0026rdquo; (i.e. compose) it to an existing circuit. Let\u0026rsquo;s see how:\nqc = QuantumCircuit(3) qc.x(0) qc.compose(OR(), [0,1,2], inplace=True) qc.draw() In the few lines above we created a quantum circuit with 3 qubits, applied an x gate to the first (just as an example) and then attached our OR gate with the compose function. This function needs the following parameters, the first one is the circuit we want to attach (the OR in this case), then a list of the order in which to attach the qubits (i.e. \u0026ldquo;connect the cables\u0026rdquo;), most of the times we want to connect the first qubit of the circuit to the first input of the gate, the second to the second and so on\u0026hellip; The final parameter inplace should always be set to True, otherwise the original circuit will not be modified.\nDrawing the circuit gives us:\nBonus tip # When working with complex circuits, things can become cluttered really fast, to hide the complexity of a circuit in the drawing, we can use the to_instruction method, which will draw our sub-circuit as a simple box:\nbox_OR = OR().to_instruction(label=\u0026#39;OR\u0026#39;) qc = QuantumCircuit(3) qc.x(0) qc.compose(box_OR, [0,1,2], inplace=True) qc.draw(\u0026#39;mpl\u0026#39;) If, on the other hand, you want to inspect how the OR circuit is built after converting it to and instruction, you can decompose it as follows:\nbox_OR = OR().to_instruction(label=\u0026#39;OR\u0026#39;) qc = QuantumCircuit(3) qc.x(0) qc.compose(box_OR, [0,1,2], inplace=True) qc.decompose().draw(\u0026#39;mpl\u0026#39;) Notice also how, decompose reveals that the x gate is, in reality, implemented as an U3 gate.\nSimulating a quantum circuit # Now we are quite good at creating circuits, but so far we haven\u0026rsquo;t run anything, let\u0026rsquo;s fix this by seeing one of the many possible ways of simulating circuits in Qiskit. The process reported here simulates a circuit ideally, i.e. without any source of noise, decoherence and so on. If you want to go into more details you should check the documentation:\nhttps://qiskit.github.io/qiskit-aer/tutorials/1_aersimulator.html https://docs.quantum.ibm.com/guides/simulate-with-qiskit-aer Before proceeding, let\u0026rsquo;s import the necessary libraries (in addition to the ones we already imported):\nfrom qiskit import transpile from qiskit_aer import AerSimulator from qiskit.visualization import plot_histogram, plot_state_city When we want to run a simulation, we also need some classical bits to \u0026ldquo;save\u0026rdquo; the results of the measurements, so let\u0026rsquo;s add them to the circuit we want to simulate. We can do this in two ways, either manually (specifying the classical bits when creating the circuit and then using them when calling measure_all), or letting the measure_all function add them for us, here I report both solution but, most of the times, the second one is more convenient.\nqc = QuantumCircuit(3, 3) qc.compose(OR(), inplace=True) qc.measure_all(add_bits=False) qc.draw(\u0026#39;mpl\u0026#39;) qc = QuantumCircuit(3) qc.compose(OR(), inplace=True) qc.measure_all() qc.draw(\u0026#39;mpl\u0026#39;) Now we are ready to run the simulation, since this is quite a complex topic to be treated in detail, I will give just a basic \u0026ldquo;recipe\u0026rdquo; that can be used in simple cases, for more advanced simulations or to understand the various steps, refer to the links above.\nsim = AerSimulator() transpiled_qc = transpile(qc, sim) result = sim.run(transpiled_qc).result() counts = result.get_counts(transpiled_qc) plot_histogram(counts) What this gives us is an histogram like the following one:\nSince this circuit is simply an OR gate, with the two inputs set to 0, we get the expected result of having all the qubits (the two inputs and the output) set to 0 since 0 | 0 = 0.\nTry messing around with the circuit (for example adding x gates to the inputs) to see if the simulation matches you expectations.\nFinal exercise # To test what you learnt, try implementing on your own a half adder. It may look complex at first, but in the end, you will only have to join together the pieces you already have with functions you already know.\nIf you need some help, I\u0026rsquo;ll provide you with the XOR gate which you may need:\n## XOR circuit def XOR() -\u0026gt; QuantumCircuit: qc = QuantumCircuit(3) qc.cx(0, 2) qc.cx(1, 2) return qc ","date":"16 May 2025","externalUrl":null,"permalink":"/en/articles/introduction-to-qiskit/","section":"Articles","summary":"This short guide explains the basics of Qiskit, how to create a quantum circuit with custom gates and how to run an ideal simulation","title":"Introduction to Qiskit","type":"articles"},{"content":" Classical Repetition Codes # Noise is a fundamental challenge in information processing systems. Many classical systems are able to avoid noise completely, while others must make use of error-correcting codes to protect against the effects of noise. The key idea is redundancy: by encoding messages with extra information, errors can be detected and corrected even if part of the data is corrupted. Repetition codes are extremely basic examples of error correcting codes.\nEncoding and Decoding Procedures # The core idea is to protect a bit against errors by repeating it multiple times. Consider the 3-bit repetition code, where a single bit is encoded as three identical bits.\n$$ \\begin{aligned} 0 \u0026amp;\\mapsto 000 \\cr 1 \u0026amp;\\mapsto 111 \\end{aligned} $$ In the absence of errors, the original bit can be trivially decoded. However, even if one bit flips, the original value can still be recovered by majority voting: the decoder outputs whichever value appears more frequently. $$ abc \\mapsto majority(a,b,c) $$ This corrects single-bit errors reliably.\nOf course, if 2 or 3 bits of the encoding flip, then the decoding won’t work properly and the wrong bit will be recovered, but if at most 1 of the 3 bits flips, the decoding will be correct. This shows a central concept in error correction: the trade-off between redundancy and robustness.\nError Analysis in Binary Symmetric Channels # As an example, suppose we wish to communicate a single bit to a hypothetical receiver through a classical noisy channel. The effect of the noise in the channel is to flip a transmitted bit with probability $p$, while with probability $1-p$ the bit is transmitted correctly. Such a channel is known as a binary symmetric channel, it flips each bit sent through it independently.\nIn this context, if we choose not to use any error correcting code and simply send whatever bit through the channel, the receiver will receive the wrong bit with probability $p$.\nOn the other hand, if we first use the 3-bit repetition code to encode the bit and then send each of the resulting three bits through the channel, each one of them will flip indipendently with probability $p$. The receiver will decode correctly only if at most one bit flips during the communication. So the probability of an error after the decoding corresponds to the probability that either two or each of the three bits flip during transmission. The total probability of an error is therefore $$ 3p^2(1-p)+p^3 = 3p^2-2p^3. $$\nThis can be obtained using probability theory. Suppose we denote with $$ p(X_1 \\cap X_2 \\cap X_3) $$ the probability that when we obtain the 3-digit bit string, we obtain the result $X_i$ for the $i$-th bit, where the outcome can be $C_i$ for correct detection and $W_i$ for a wrong one.\nLet’s consider the case where all three bits are wrong. Since the three events are independent (we assumed this at the beginning), the theory tells us that the probability of the intersection of the events is the product of the probabilities of the single events, $$ p(W_1 \\cap W_2 \\cap W_3) = p(W_1) p(W_2) p(W_3) = p^3. $$ Analyzing the other case, we see that one possible scenario is the following: $$ p(C_1 \\cap W_2 \\cap W_3) = p(C_1) p(W_2) p(W_3) = (1-p)p^2. $$ But this can also occur (with the same calculation): $$ p(W_1 \\cap C_2 \\cap W_3) = (1-p)p^2, $$ and $$ p(W_1 \\cap W_2 \\cap C_3) = (1-p)p^2. $$ The final expression for the event of only one correct bit is $$ p\\big((C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big). $$\nSince the three composite events considered have an empty intersection (a bit cannot be simultaneously correct and wrong), the theory tells us that we can simply sum the single probabilities, $$ \\begin{aligned} p\u0026amp; \\big((C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big) = \\cr \u0026amp;= p(C_1 \\cap W_2 \\cap W_3) + p(W_1 \\cap C_2 \\cap W_3) + p(W_1 \\cap W_2 \\cap C_3) = \\cr \u0026amp;=3(1-p)p^2. \\end{aligned} $$\nFinally, we have to consider the composite event of all errors or only one correct bit. Since those have an empty intersection, we end up with $$ \\begin{aligned} p\u0026amp;\\Big( \\big( (C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big) \\cup (W_1 \\cap W_2 \\cap W_3) \\Big) = \\cr \u0026amp;= p^3 +3(1-p)p^2 =3p^2 -2p^3. \\end{aligned} $$\nBinary Symmetric Error As can be seen in above figure, when the error probability $p$ is less than $1/2$, the repetition code effectively reduces the chance of the receiver obtaining an incorrect bit. Conversely, if $p$ exceeds $1/2$, the code amplifies the likelihood of decoding errors rather than correcting them.\nQuantum Repetition Codes for Qubits # The 3-bit repetition code can be used also for qubit error correction.\nEncoding Quantum States # To create a 3-qubit repeated entangled state, we can use the circuit shown in the figure below. Thanks to this circuit we can encode the generic state $\\alpha \\ket{0}+ \\beta \\ket{1}$ into the state $\\alpha \\ket{000}+ \\beta \\ket{111}$, thanks to the action of the controlled NOT (CNOT) gates.\n3-qubit bit flip code circuit diagram Notice that this encoding is different from the repetition of the same state three times $\\ket{\\psi}\\otimes\\ket{\\psi}\\otimes\\ket{\\psi}$, which would be impossible due to the no cloning theorem.\nDetecting and Correcting Bit-Flip Errors # The first type of error we can correct with repetition qubits is the bit flip. This sort of error is represented as an $X$ gate. If one of the three qubits, say the middle one, undergoes this type of error, the final state of the system would be $\\alpha \\ket{010}+ \\beta \\ket{101}$. In order to detect this bit flip we could measure the state, but this would destroy the superposition.\nHow can we try to understand which of the three qubits flipped without measuring directly the state? The correct way to do this is add a new piece to our system. This should be a system that start decoupled from our system, enter in contact with the main state and get influenced by it in a predictable way, but end up again in a decoupled state at the end. When i speak about decoupled i really refer, in a formal way, to what is called a separable state. The main property of a separable state is that if we measure one of the separated portion of our system we don’t perturb the rest. So we can exploit this property to deduce, measuring the new system, which of the three bits flipped ( assuming we have only a single flip). Then we can apply the inverse $X$ gate, so $X$ itself, to the wrong qubit to get again the initial state.\nThis cleared, and recalling that with $n$ qubit we can obtain $2^n$ different measurements, we need only 2 qubits that can index the $2^2 = 4$ different outcomes:\n00 if we have no errors;\n01 if the bit with error is the third one;\n10 if the bit with error is the first one;\n11 if the bit with error is the second one.\nNow, let’s see how can we design a circuit that is respecting all the premises. Consider our starting state as $$ \\alpha \\ket{000} + \\beta \\ket{111}. $$ For example, if an error occurs on the first qubit, we end up with the state $$ \\alpha \\ket{100} + \\beta \\ket{011}. $$ Now, we can try to use some gates, such as C-NOTs, to make this change affect the bottom two qubits. We can do this as shown in the following figure.\nCorrecting an error on the first qubit Applying that CNOT, denoted as ${CX}_{i \\to j}$, meaning that the control qubit is the $i$-th one, we end up with\n$$ \\begin{aligned} \\CX{1}{4} \\left( (\\alpha \\ket{100} + \\beta \\ket{011}) \\otimes \\ket{00} \\right) = \\cr = \\CX{1}{4} (\\alpha \\ket{100} \\otimes \\ket{00}) + \\CX{1}{4} (\\beta \\ket{011} \\otimes \\ket{00}) = \\cr = \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{00} \\end{aligned} $$\nwhere we exploited linearity in the second step. We notice that the CNOT acted only on the first part of our superposition state. This is not a state we want to obtain in the end because it is not separable, so we cannot put it in a form like $$ \\begin{aligned} (\\alpha \\ket{100}+ \\beta \\ket{011} ) \\otimes \\ket{10} \\end{aligned} $$ That is the state we would like to obtain since we want to measure the last two qubits and obtain the string $10$, which tells us that the error occurred on the first qubit, all without perturbing our original state (the first three qubits).\nSo we need to modify the second part of the state, the one linked to the coefficient $\\beta$, to end up with $\\beta \\ket{011} \\otimes \\ket{10}$. How can we do this? Since the $\\alpha$ term has the first qubit set to $1$, we can apply a CNOT to the second or the third qubit without modifying that part of the state. So we can apply the CNOT to the second one as shown.\nCorrecting an error on the first qubit (2) In this way, we can obtain, by applying the gate: $$ \\begin{aligned} \\CX{2}{4} \\big( \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{00} \\big) = \\cr = \\CX{2}{4} (\\alpha \\ket{100} \\otimes \\ket{10}) + \\CX{2}{4} (\\beta \\ket{011} \\otimes \\ket{00}) = \\cr = \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{10} = \\cr = \\big( \\alpha \\ket{100} + \\beta \\ket{011} \\big) \\otimes \\ket{10} \\end{aligned} $$\nthat is the state we want to get.\nError on the third qubit If we now consider an error on the third qubit like in the image, resulting in a state like $$ \\alpha \\ket{001} + \\beta \\ket{110}, $$ we see that our circuit is not working correctly. In fact, $$ \\begin{aligned} \\CX{2}{4} \\CX{1}{4} \\big( (\\alpha \\ket{001} + \\beta \\ket{110}) \\otimes \\ket{00} \\big) = \\cr = \\CX{2}{4} \\CX{1}{4} (\\alpha \\ket{001} \\otimes \\ket{00}) + \\CX{2}{4} \\CX{1}{4} (\\beta \\ket{110} \\otimes \\ket{00}) = \\cr = \\alpha \\ket{001} \\otimes \\ket{00} + \\beta \\ket{110} \\otimes \\ket{00} = \\cr = \\big( \\alpha \\ket{001} + \\beta \\ket{110} \\big) \\otimes \\ket{00}. \\end{aligned} $$\nNotice that in this case, the CNOT acting on the first term of the superposition (the $\\alpha$ term) does nothing, while the second term results in two consecutive flips that cancel each other out. So here, the action of the gates is equivalent to the identity. We end up with no information about the error. We can correct this situation by adding CNOTs; like in the previous situation, we need to add two of them to create a separable state as shown here.\nError corrected on the third qubit In this way, we end up with the result $01$ if we have an error on the third bit. Remember that the first two CNOTs act like the identity in this situation.\nIf we return to the previous case, the one with the error on the first qubit, we see that the situation is symmetric: the two gates we added at the end act like the identity, while the first two act as we described previously; everything still works. Moreover, this circuit acts on the no-error state as the identity.\nError on the second qubit The last case we need to investigate is the error on the central qubit. We want, in this case, to obtain the result $11$. Let’s see what happens with the current circuit. We notice that the first and the last CNOTs act only on the $\\beta$ part of the superposition. The middle ones, instead, act only on the $\\alpha$ part. If we check, we end up with the separable state of the desired type: $$ \\big( \\alpha\\ket{010}+\\beta\\ket{101} \\big) \\otimes \\ket{11}. $$ Our circuit works!\nSummarizing, we can easily compute the measurement outcomes (syndromes) for all the states obtained from at most one bit-flip, they are listed in the following table.\nState Syndrome $\\alpha \\ket{000}+ \\beta \\ket{111}$ 00 $\\alpha \\ket{100}+ \\beta \\ket{011}$ 10 $\\alpha \\ket{010}+ \\beta \\ket{101}$ 11 $\\alpha \\ket{001}+ \\beta \\ket{110}$ 01 It is important to underline that perfect bit-flip errors are just a simple model of a much more complex phenomenon, here we easily assumed one flip represented by a unitary operator. We will discuss about non unitary errors by the end of the article.\nHandling Phase-Flip Errors # Another fundamental type of errors we have to worry about are phase-flip errors, modeled as $Z$ gates. Applying a $Z$ gate to any of the three qubits of the previous encoding we obtain $$ (\\mathbb{I}\\otimes Z \\otimes \\mathbb{I})(\\alpha \\ket{000}+ \\beta \\ket{111})=\\alpha \\ket{000}- \\beta \\ket{111}. $$ It turns out that phase-flips on any of the three qubits have the same effect on the whole final state, leading to a total phase flip for an odd number of $Z$ gates applied. Unfortunately our previous error correction circuit is not able to detect phase-flip errors, the output in the ancilla qubits will be $00$ anyway, not detecting any error.\nModified Repetition Code for Phase-Flip Mitigation # In order to detect phase flip errors, we must modify the encoded state $\\alpha \\ket{000}+ \\beta \\ket{111}$ by applying three Hadamard gates, reaching then the state $\\alpha \\ket{+++}+ \\beta \\ket{\u0026mdash;}$. This is done by the circuit in the figure below. 3 qubit phase correcting diagram - first part After this encoding, a phase-flip error will transform a $\\ket{+}$ state in a $\\ket{-}$ and viceversa. So adding two ancilla qubits in $\\ket{+}$ state, we will be able to reproduce a circuit analogous to the one done for bit-flips, represented in the diagram.\n3 qubit complete phase correcting diagram As before the measured syndorme will tell us if and where the error occurred.\nCorrecting phase-flip errors force us to a change of basis, done by means of Hadamard gates.\nThe 9-Qubit Shor Code # The 9-qubit Shor error correcting code is a obtained combining the 3-bit repetition code for bit-flip and phase-flip errors described before.\nCode Structure and Encoding # The two error correcting codes just seen will be concatenated, resulting so in a 9-qubits circuit in the end. These two codes can be applied in both orders, so we made the choice to apply first the phase-flip error correcting code (outer code), the resulting qubits will be then encoded using the 3-bit repetition code for bit-flip errors (inner code), as in the figure below.\n9-qubit Shor code circuit diagram In this way, the resultant action of the circuit on the original qubit basis states is the following: $$ \\begin{aligned} \\ket{0} \u0026amp;\\mapsto \\frac{1}{2\\sqrt{2}}(\\ket{000}+\\ket{111})\\otimes(\\ket{000}+\\ket{111})\\otimes(\\ket{000}+\\ket{111}) \\cr \\ket{1} \u0026amp;\\mapsto \\frac{1}{2\\sqrt{2}}(\\ket{000}-\\ket{111})\\otimes(\\ket{000}-\\ket{111})\\otimes(\\ket{000}-\\ket{111}). \\end{aligned} $$\nError Propagation and CNOT Gate Operations # Now before going and see how errors affect our encoding, we must stop to introduce some important relationships and equivalences regarding $X$ and $Z$ errors. The following equivalences can be verified calculating the matrix multiplications or by writing down the truth tables for X gates and X gates with the CNOT. X gates and CNOT gates relationships Z gates and CNOT gates relationships Correction of Bit-Flip Errors # Considering a bit-flip error affecting our circuit, we can focus on each of the three blocks separately. It is easy to see that each of them is the encoding of a single qubit using the 3-bit repetition code for bit-flip errors, so exploiting two ancilla qubit per block we can measure and correct up to one bit-flip error per block.\nCorrection of Phase-Flip Errors # Since the code designed to correct phase-flips is not affected directly by the errors, showing the capabilities of the Shor code to detect this kind of errors will be more difficult given our order of encoding.\nSupposing a $Z$ error affecting one of the 9 qubits, we can use the equivalences introduced before to show that it is equivalent to one phase-flip error occurring prior the inner encoding, as seen below.\nPhase-Flip Error Equivalence in Shor Code So a $Z$ error occurring in any of the three qubits within a block has the same effect on the final state of a $Z$ error occurring before the inner code.\nWhat we can do to deal with phase-flip errors is to model the $Z$ error as happening before the inner code; so decode the former to go back to the first stage of encoding. Now our original qubit is just encoded using the repetition code for phase-flips. In this way we can just use two ancilla qubits as before to check the correctness of our state, and then encode again each of the three qubits with the bit-flip code. The syndrome will detect the block in which the phase flip occurred, see figure below.\nShor Correct Z In the end we can simplify the previous circuit using four CNOT gates less, as in the figure below.\nShor Correct Z Simplified Simultaneous Bit and Phase-Flip Error Correction # We’ve just seen how both $X$ and $Z$ errors can be detected and corrected using the Shor code. Let’s now consider the scenario in which both a bit-flip and a phase-flip error happen simultaneously, possibly on the same qubit; we’ll see that the Shor code is able to handle this scenario without further modifications.\nSince $X$ and $Z$ errors matrices anticommute: $$ XZ = \\begin{pmatrix}0\u0026amp;1\\cr1\u0026amp;0\\end{pmatrix} \\begin{pmatrix}1\u0026amp;0\\cr0\u0026amp;-1\\end{pmatrix}= \\begin{pmatrix}0\u0026amp;-1\\cr1\u0026amp;0\\end{pmatrix}=-\\begin{pmatrix}1\u0026amp;0\\cr0\u0026amp;-1\\end{pmatrix}\\begin{pmatrix}0\u0026amp;1\\cr1\u0026amp;0\\end{pmatrix}=-ZX $$ inverting them just causes an irrilevant global phase factor of $-1$. So, no matter in which order the errors occur, we are always able to propagate the $Z$ error prior to the inner code. At this point it is important to notice that the procedures to detect and eventually correct bit-flip and phase-flip errors can be performed indipendently introducing enough ancilla qubits, so we can simply first apply the procedure to detect the $X$ error, and then apply the procedure to detect the $Z$ error to finally recover the correct initial state. To be precise it is not important at all the order in which the procedures are performed, since $X$ gates on any of the nine qubits of the encoding commute with all the gates of the simplified circuit to correct phase-flip errors (The Simplified Shor figure above); so also inverting the order of the procedures will correctly detect both the errors.\nRobustness Against Random Errors # Before considering arbitrary quantum errors, let’s analyze the performance of the 9-qubit Shor code when random errors rapresented by Pauli matrices occur on the qubits.\nLet’s consider a simple noise model where each qubit experiences an error with probability $p$, the errors occur indipendently. To keep things simple we analyze the worst case scenario\nConsider a scenario where errors strike qubits independently with probability $p$, analogous to the binary symmetric channel in classical systems. For simplicity, assume no correlations between errors. While distinct probabilities could be assigned to $X$, $Y$, and $Z$ errors, we focus on the worst-case scenario for the Shor code: $Y$ errors. Since $Y$ errors are equivalent to simultaneous $X$ and $Z$ errors up to a global phase factor, them represents both bit-flip and phase-flip errors.\nSuppose we encode a logical qubit using the Shor code, whether we get an advantage or not depends on the error probability $p$. Similar to the classical 3-bit repetition code, which becomes disadvantageous when $p\u0026gt;1/2$, also for the Shor code we can find such a threshold and quantify its performance.\nThe 9-qubit Shor code is able to correct any Pauli error on a single qubit, including so $Y$ errors, but it fails if more then one $Y$ error occur on different qubits. Since in our scenario we focus on $Y$ errors, the code is reliable and protects our logical qubit as long as at most one of the physical qubits is affected by an error, which happens with probability $$ (1-p)^9 + 9p(1-p)^8. $$ Otherwise, the code fails with probability $$ 1-(1-p)^9-9p(1-p)^8. $$\nIs not sure that the happening of more then one Pauli error lead to wrong decoding of the original qubit state, but for the sake of this analysis we consider this scenario as a failure. We say in this case a logical error affected our logical qubit. On the other hand, if we do not use the code our single physical qubit suffers logical errors with probability $p$, so the code gives a real advantage only for $p$ such that $$ 1-(1-p)^9-9p(1-p)^8\u0026lt;p. $$\nShor Performance Threshold As we can see in the above figure the threshold for the 9-qubit Shor code is about $0.0323$. If $p$ is smaller of the former value, the code is helping, it has diminished the likelihood of an error to occur, but if $p$ is greater then the threshold, we should not use the code since it would worsen the robustness to noise of our system w.r.t a single physical qubit.\nError Discretization in Quantum Systems # The 9-qubit Shor code corrects arbitrary quantum errors-not just $X$ or $Z$ errors-by leveraging its ability to correct $X$ and $Z$ errors separately. This works because any possible single-qubit error can be decomposed into a combination of $X$, $Z$, or both (a property known as the discretization of errors). Since the code detects and corrects $X$ and $Z$ errors independently, it inherently handles all other errors as well. Thus, no additional mechanisms are needed: correcting $X$ and $Z$ suffices to protect against arbitrary quantum noise. First we focus on Unitary Errors.\nModeling Unitary Qubit Errors # The 9-qubit Shor code can correct any single-qubit unitary error, even those that are not close to the identity (e.g., small rotations or arbitrary unitary operations). While it may seem challenging to correct infinitely many possible errors, the key insight is that any single-qubit unitary $U$ can be decomposed into a linear combination of Pauli operators: $$ U = \\alpha I + \\beta X + \\gamma Y + \\delta Z $$ where $Y = iXZ$.\nWhen an error $U_k$ occurs on the $k$-th qubit, the corrupted state becomes a superposition of the original state and states with $X_k$, $Z_k$, or $X_kZ_k$ errors. During error detection, the syndrome measurements probabilistically collapse this superposition into one of the Pauli error cases (or no error), with probabilities $|\\alpha|^2$, $|\\beta|^2$, $|\\gamma|^2$, and $|\\delta|^2$. The syndrome reveals which error occurred, allowing its correction. Remarkably, this process works even for tiny errors, as the syndrome measurements discretize the error into a Pauli operation, which the code is designed to fix. After correction, the system returns to the original encoded state, effectively removing the entropy introduced by the error. This demonstrates the discretization of errors: arbitrary unitary errors are reduced to correctable Pauli errors through syndrome measurement.\nThe 9-qubit Shor code corrects arbitrary unitary errors through error discretization. For multi-qubit errors, we formally represent operations using tensor products with identity matrices. Using Qiskit’s qubit numbering $(Q_8,Q_7,\u0026hellip;,Q_0)$, single-qubit operations extend to the 9-qubit space as:\n$$ \\begin{aligned} X_0 \u0026= I^{\\otimes 8} \\otimes X = I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes X\\cr Z_4 \u0026= I^{\\otimes 4} \\otimes Z \\otimes I^{\\otimes 4}=I\\otimes I\\otimes I\\otimes I\\otimes Z \\otimes I\\otimes I\\otimes I\\otimes I \\cr U_7 \u0026= I \\otimes U \\otimes I^{\\otimes 7} =I\\otimes U\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I \\end{aligned} $$ where $I^{\\otimes n}$ denotes an $n$-fold tensor product of identity matrices. An arbitrary unitary error $U_k$ on qubit $k$ decomposes into Pauli operators as: $$ U_k = \\alpha I^{\\otimes 9} + \\beta X_k + \\gamma Y_k + \\delta Z_k $$\nwith $X_k$, $Z_k$ defined similarly to the previous operator definitions, and $Y_k = iX_kZ_k$. For multiple errors, the formalism extends naturally: $$ U_{j,k} = (I^{\\otimes (8-j)} \\otimes U_j \\otimes I^{\\otimes j}) \\cdot (I^{\\otimes (8-k)} \\otimes U_k \\otimes I^{\\otimes k}) $$\nThe syndrome measurement projects these continuous errors onto discrete Pauli operators. For example, a two-qubit error $U_{2,5}$ would collapse to one of $I$, $X_2$, $Z_5$, $X_2Z_5$, etc., with probabilities determined by the decomposition coefficients. The tensor product structure ensures correct identification of affected qubits through the syndrome pattern. $$ \\xi \\otimes \\ket{\\psi}\\bra{\\psi} $$ where $$ \\begin{aligned} \\xi \u0026amp;= |\\alpha|^2 \\ket{I { syndrome}}\\bra{I { syndrome}}\\cr \u0026amp;+ |\\beta|^2 \\ket{X_k { syndrome}}\\bra{X_k { syndrome}}\\cr \u0026amp;+ |\\gamma|^2 \\ket{X_kZ_k { syndrome}}\\bra{X_kZ_k { syndrome}}\\cr \u0026amp;+ |\\delta|^2 \\ket{Z_k { syndrome}}\\bra{Z_k { syndrome}}. \\end{aligned} $$\nGeneral Arbitrary Qubit Errors # We now examine arbitrary (not necessarily unitary) errors on qubits. Specifically, we model the error using a general quantum channel $\\Phi$, which could represent various noise processes-such as dephasing, depolarization, reset operations, or even unconventional, less-studied channels.\nTo analyze $\\Phi$, we first express it in terms of Kraus operators: $$ \\Phi(\\sigma) = \\sum_j A_j \\sigma A_j^\\dagger, $$ where each $A_j$ is a $2 \\times 2$ matrix. Since the Pauli matrices form a basis for such operators, we expand each $A_j$ as: $$ A_j = \\alpha_j I + \\beta_j X + \\gamma_j Y + \\delta_j Z. $$ This decomposition allows us to rewrite the action of $\\Phi$ on a target qubit $k$ in terms of Pauli errors: $$ \\begin{aligned} \\Phi_k \\big( \\ket{\\psi}\\bra{\\psi} \\big) \u0026amp;= \\sum_j \\big( \\alpha_j I_k + \\beta_j X_k + \\gamma_j Y_k + \\delta_j Z_k \\big) \\ket{\\psi}\\bra{\\psi} \\cr \u0026amp;\\quad \\times \\big( \\alpha_j I_k + \\beta_j X_k + \\gamma_j Y_k + \\delta_j Z_k \\big)^\\dagger. \\end{aligned} $$ In essence, we have reformulated the Kraus operators as linear combinations of Pauli terms.\nUpon measuring the error syndrome and applying the appropriate correction, the resulting state resembles the unitary error case, albeit with a more complex mixture: $$ \\xi \\otimes \\ket{\\psi}\\bra{\\psi}, $$ where $\\xi$ now incorporates contributions from all Kraus terms: $$ \\begin{aligned} \\xi \u0026amp;= \\sum_j \\Big( |\\alpha_j|^2 \\ket{I { syndrome}}\\bra{I { syndrome}} \\cr \u0026amp;\\quad + |\\beta_j|^2 \\ket{X_k { syndrome}}\\bra{X_k { syndrome}} \\cr \u0026amp;\\quad + |\\gamma_j|^2 \\ket{X_kZ_k { syndrome}}\\bra{X_kZ_k { syndrome}} \\cr \u0026amp;\\quad + |\\delta_j|^2 \\ket{Z_k { syndrome}}\\bra{Z_k { syndrome}} \\Big). \\end{aligned} $$\nWhile the explicit derivation involves more terms, the underlying principle remains identical to the unitary scenario: syndrome extraction and correction project the error into distinguishable Pauli components.\nExtensions and Generalizations # The discretization of errors naturally extends to more general quantum error-correcting codes, including those capable of detecting and correcting errors across multiple qubits. In such scenarios, multi-qubit errors can be represented as tensor products of Pauli matrices: $$ E = \\bigotimes_{k=1}^n P_k \\quad {where} \\quad P_k \\in {I, X, Y, Z}, $$ and distinct syndromes identify corresponding Pauli corrections that may need to be applied to multiple qubits simultaneously, rather than just a single qubit.\nThrough syndrome measurement, errors are effectively projected onto a discrete set of possibilities characterized by these Pauli tensor products. By applying the appropriate corrections, we can recover the original encoded state. The randomness introduced during this process is confined to the syndrome qubits, which are subsequently either discarded or reset. This mechanism effectively removes the generated randomness from the system containing the encoded information, preserving the integrity of the quantum computation.\nThe fundamental principle remains consistent with the single-qubit case: error correction proceeds by\nIdentifying error syndromes through measurement,\nDetermining the corresponding Pauli corrections, and\nIsolating the randomness in ancillary qubits that are then removed from the system.\nThis approach maintains the essential features of quantum error correction while scaling to more complex, multi-qubit error patterns.\nReferences # IBM Quantum Learning \u0026ldquo;Correcting quantum errors\u0026rdquo;.\n","date":"17 May 2025","externalUrl":null,"permalink":"/en/articles/quantum-error-correction/","section":"Articles","summary":"Using techniques like repetition codes and the 9-qubit Shor code, quantum error correction enables reliable quantum computing by protecting qubits from bit-flip errors, phase-flip errors, and arbitrary errors.","title":"Quantum Error Correction","type":"articles"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/articles/","section":"Articles","summary":"","title":"Articles","type":"articles"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/authors/edoardo-frulla/","section":"Authors","summary":"","title":"Edoardo Frulla","type":"authors"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/authors/leonardo-niccolai/","section":"Authors","summary":"","title":"Leonardo Niccolai","type":"authors"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/authors/mattia-corrado-plac%C3%AC/","section":"Authors","summary":"","title":"Mattia Corrado Placì","type":"authors"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/tags/qec/","section":"Tags","summary":"","title":"QEC","type":"tags"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/tags/qiskit/","section":"Tags","summary":"","title":"Qiskit","type":"tags"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"17 May 2025","externalUrl":null,"permalink":"/en/authors/walid-bou-ezz/","section":"Authors","summary":"","title":"Walid Bou Ezz","type":"authors"},{"content":"","date":"16 May 2025","externalUrl":null,"permalink":"/en/authors/giacomo-bertelli/","section":"Authors","summary":"","title":"Giacomo Bertelli","type":"authors"},{"content":"","date":"16 May 2025","externalUrl":null,"permalink":"/en/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"28 April 2025","externalUrl":null,"permalink":"/en/authors/enrico-pavese/","section":"Authors","summary":"","title":"Enrico Pavese","type":"authors"},{"content":"","date":"28 April 2025","externalUrl":null,"permalink":"/en/authors/francesco-zanti/","section":"Authors","summary":"","title":"Francesco Zanti","type":"authors"},{"content":"","date":"28 April 2025","externalUrl":null,"permalink":"/en/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"28 April 2025","externalUrl":null,"permalink":"/en/authors/marc-helou/","section":"Authors","summary":"","title":"Marc Helou","type":"authors"},{"content":"","date":"28 April 2025","externalUrl":null,"permalink":"/en/tags/superconducting/","section":"Tags","summary":"","title":"Superconducting","type":"tags"},{"content":" Introduction # In this first lesson, we - the marvellous Hardware division - will explain you the first theoretical concepts of superconducting quantum computers. The article is divided into three sections:\nin the first one, there is a brief discussion about fundamental concepts of superconductivity; in the second one, we will explain you how to encode information using superconductivity; lastly, we will talk about the manipulation of this information. Ready to join us? Let\u0026rsquo;s start!\nTheoretical Foundations of Superconductivity # In the pursuit of robust and scalable quantum computing technologies, superconducting circuits have emerged as one of the most promising platforms. Among the various superconducting qubit architectures, the transmon qubit stands out for its balance between coherence, tunability, and scalability. At the heart of this design lies the phenomenon of superconductivity, a macroscopic quantum state that allows the creation of circuit elements like Josephson junctions, essential components for transmon operations. To fully grasp the principles behind transmon qubits, one must first understand the fundamental physics of superconductivity.\nSuperconductivity # Lossless Conduction and Meissner Effect # Superconductivity is a state in which a material exhibits zero electrical resistance below a critical temperature $T_c$. This lossless conduction is not simply an extension of ideal conductivity, but rather a manifestation of a new quantum phase of matter. Additionally, superconductors expel magnetic fields from their interior (the Meissner effect), a distinctive trait that sets them apart from perfect conductors.\nCritical Quantities # A superconducting material transits to its normal (resistive) state when subjected to:\nTemperatures above $T_c$ Magnetic fields exceeding the critical magnetic field $H_c (T)$ Currents above a critical current $I_c$ The temperature dependence of the critical field is given by the empirical law:\n$$ \\begin{aligned} H = H_{c_0} \\cdot \\left(1 - \\left(\\frac{T}{T_{c}}\\right)^2 \\right) \\end{aligned} $$\nand according to Ampère\u0026rsquo;s Law, this critical field relates to the maximum current sustainable by the material, wich is: $I_c = 2 \\pi R H_c$\nCharge carriers in superconductors # In the superconducting state, conduction electrons form bound pairs known as Cooper pairs, which behave as bosons. Coupling mechanisms are different, here we\u0026rsquo;ll deal for simplicity with the phonon coupling, the easiest - nonethless the only one analytically described by BCS theory. It works in this way: as an electron moves through the lattice, it distorts it due to Coulomb attraction with the lattice\u0026rsquo;s ions, creating a local positive potential that attracts another electron.\nBecause these pairs have integer spin, they do not follow the Pauli exclusion principle and can condense into a single quantum state, leading to the macroscopic coherence of the superconducting phase.\nMacroscopic Wave Function # Each Cooper pair contributes to a collective quantum state described by a macroscopic wave function:\n$\\Psi(r, t) = \\Psi_0 \\cdot e^{-j(\\omega t + \\phi)}$\nThis wavefunction is extended to the entire superconductor and its phase $\\phi$ becomes a key player in superconducting circuit dynamics, since it\u0026rsquo;s related to the external magnetic field acting on the junction, as we are going to see in a while.\nJosephson Junction and Josephson Effect # A Josephson Junction (JJ) consists of two superconductors separated by a thin insulating layer. Due to the tunnel effect of the macroscopic wavefunction, a supercurrent can flow through this insulator, a phenomenon known as the Josephson effect.\nImportantly, it\u0026rsquo;s not individual Cooper pairs but the macroscopic wavefunctions that interfere and allow for the current: $ I = I_c \\cdot \\sin(\\phi) $\nWhere $\\phi = \\phi_2 - \\phi_1$ is the phase difference across the junction, referred to the phase of the two wavefunctions defined respectively for the two superconducting sides of the JJ.\nThis nonlinear relationship is responsable for the JJ behaviour of nonlinear inductor, with an effective inductance:\n$$ \\begin{aligned} L(\\phi) = \\frac{\\Phi_0}{2 \\pi I_c \\cos(\\phi)} \\end{aligned} $$\nwith\n$L_j = (\\Phi_0)/(2 \\pi I_c)$\ndefined as the Josephson inductance\nHere,\n$\\Phi_0 = \\frac{h}{2e} \\approx 2.07 \\times 10^{-15} Wb$ is the magnetic flux quantum, i.e. a costant that referres to the smallest quanta of magnetic flux we can consider.\nEnergy Considerations # The Josephson junction stores energy as: $E(\\phi) = E_J \\cdot (1 - \\cos(\\phi))$\nWhere: $E_J = \\frac{I_c \\Phi_0}{2 \\pi}$ is the Josephson energy. This energy landscape is periodic with the phase difference defined above, and can be tuned by an external magnetic field acting on the JJ - as we\u0026rsquo;re going to see in a while.\nVoltage – Phase and Flux Relations # From the relation between voltage $V$ and the phase difference $\\phi$:\n$ \\frac{d \\phi}{d t} = \\frac{2 \\pi V}{\\Phi_0} $\nwe can define the quantity electric flux $\\Phi$ as:\n$ \\Phi = \\int_0^t V(t\u0026rsquo;) d t\u0026rsquo; = \\frac{\\Phi_0}{2 \\pi}(\\phi - \\phi_0) $\nfrom which we can express $\\phi= \\frac{2\\pi \\Phi}{\\Phi_0} + \\phi_0$\nSuperconducting qubits: from the LC-Circuit to the Transmon Qubit # Now that we gave a look at the physics of superconductivity we\u0026rsquo;ll see how we can use it to build a quantum unit of information. Starting from classic circuitry we are going to build the structures where Cooper pairs will be used as carriers of information.\nQubit review # We\u0026rsquo;ll start with a basic review of said quantum unit of information, the quantum bit or qubit. In classical theory of information, the basic unit of measurement is the binary digit, or bit, which can take on one of two values, either 0 or 1. Its quantum counterpart is the qubit which thanks to the superposition of states, a mere result of the founding mathematics of quantum mechanics, can hold information equal to all infinite combinations of 0 and 1. Physically, a qubit is a two-level system which can be manipulated and read differently based on the technology used to implement it. Using Dirac\u0026rsquo;s notation we can define a qubit as:\n$$ \\begin{aligned} \\Psi = \\alpha\\ket{0} + \\beta\\ket{1} \\end{aligned} $$\nWhere $\\alpha$ and $\\beta$ are complex numbers that must fulfill the relation:\n$|\\alpha|^2+|\\beta|^2 = 1$\nLC circuits and Transmission Lines # Having in mind the objective of building a qubit out of superconducting circuitry we\u0026rsquo;ll start by studying a basic yet fundamental electric circuit which is at the foundations of both the qubit itself and its manipulation system.\nLC circuit # This simple LC circuit is made by a parallel of an inductor and a capacitor. It acts as an electrical resonator storing energy by oscillating at the circuit\u0026rsquo;s resonant frequency. The energy is divided between the charge inside the capacitor and the magnetic field formed inside the inductor by the passing current and can be described by the following Hamiltonian:\n$$ \\begin{aligned} H = \\frac{Q^2}{2C} + \\frac{\\Phi^2}{2L} \\end{aligned} $$\nDue to the quadratic form of the energy, the potential landscape inside such a circuit is parabolic.\nBy applying the circuit quantization procedure one obtaines the Hamiltonian of the quantum harmonic oscillator with discrete allowed energies arising in the potential profile. The Hamiltonian of the quantum harmonic oscillator can be rewritten through the creation and annhilition operators formalism as:\n$$ \\begin{aligned} \\hat{H} = \\hbar w_r \\left( \\hat{a}^ \\dagger \\hat{a} + \\frac{1}{2}\\right) \\end{aligned} $$\nNotice that the harmonicity causes the jumps in energy to be all equal to $\\hbar w_r$ with $w_r = \\frac{1}{\\sqrt{L C}}$ being the circuit\u0026rsquo;s resonant frequency.\nTransmission Line # The transmission line is a model for circuits that transport electromagnetic energy without significant losses. It can be schematized as a lumped-element model composed of an array of coupled LC circuits. By shorting both ends of the transmission line to the ground one obtains a proper resonator where the admitted wavevectors are discretized as:\n$k = {2 \\pi n}/L$\nwith L being the resonator lenght and $n = 1, 2, 3\u0026hellip;$\nThe Hamiltonian can be again be written in terms of creation and annihilation operators which create and annihilate a wave with wavevector $k$:\n$$ \\begin{aligned} \\hat{H} = \\sum_{n=0} \\hbar w_n [\\hat{a}(w_n)^ \\dagger \\hat{a}(w_n)] \\end{aligned} $$\nwith $w_n = (n+1) w_r$ being the frequencies of the admitted modes. The concept of the transmission line as a resonator will come useful in the following parts when it will be used to read the state of the qubit by capacitive coupling.\nSuperconducting qubits # Using the concepts illustrated above we\u0026rsquo;ll now move toward building a superconducting qubit. For this goal we\u0026rsquo;ll need to merge classical electronic concepts like the LC circuit with a bit of superconducting magic.\nArtificial atoms # When using a technology to make a qubit we need to keep in mind how we want this to behave. The concept of artificial atoms is the model that precisely describes the desired characteristics of the qubit in the making. We basically want our physical system to behave like a natural atom, with its inhomogeneous and descrete energy jumps which can be controlled by accurately sending some sort of signals and likewise be easily read. What we aim for are sharp energy levels and anharmonic transitions so that a signal tuned at the difference between two energy levels will address only that one and other energy jumps will be transparent to it.\nIn the case of qubits as artificial atoms we would mostly like the carriers of information, in our case Cooper pairs, to hold the information for long times which in this framework can be said to aspire to long coherence times. It is also fundamental to avoid thermal fluctuations with energies higher than the addressed transition, so that undesired excitations are avoided. Finally, the major risk of decoherence by enviromental influences must be contained adequately.\nCharge Qubits # Let\u0026rsquo;s take now the LC circuit described above and let\u0026rsquo;s replace the linear inductor with a Josephson junction. What we will get is the first form of superconducting qubit we can regard, also called a charge qubit.\nThe charge qubit is simply made by a Josephson junction shunted by a capacitor. The core difference with respect to a normal LC circuit is the non-linear behavior of the junction. The capacitor connecting the source to the junction symbolizes the capacitive coupling of the qubit to an arbitrary voltage source. The sinusoidal characteristic of the junction current gives rise to an anharmonic profile in its potential:\n$$ \\begin{aligned} \\hat{H} = 4E_c \\hat{n}^2 - E_j cos(\\phi) \\end{aligned} $$\nwhere $\\hat{n}$ is the number operator which is directly linked to the creation and annihilation operators and represents the number of Cooper pairs inside the circuit, $E_c$ is the charging energy that has an inverse proportionality with respect to the shunting capacitor and $E_j$ is the Josephson energy while $\\phi$ is the phase difference of the macroscopic wavefunction across the junction.\nThe quadratic behavior of the energy now lies entirely in the number operator while the non-linear potential of the junction gives rise to anharmonic jumps inside its profile.\nThanks to the anharmonicity of the potential, the descrete energy transitions accessible in a quantum framework are now uneven allowing to address two states independently.\nTransmon Regime # Historically, the first implementations of superconducting qubits were charge qubits where the information is encoded in the amount of Cooper pairs inside the superconducting circuit. The main source of noise that degrades such systems is charge noise which is due to nearby charges driven by the voltage source that the qubit might collect. They\u0026rsquo;re modellable as a parametric fluctuation ($n_g$) in the number of carriers in the Hamiltonian:\n$$ \\begin{aligned} \\hat{H} = 4E_c (\\hat{n}^2-n_g^2) - E_j cos(\\phi) \\end{aligned} $$\nthe fluctuation might even change with time. The main consequence of charge noise is to change the transition frequencies making it almost impossible to control the qubit.\nIn order to mitigate the influence of this kind of noise the Josephson energy must overcome the charging energy. Implementing a Superconducting Quantum Interference Device (SQUID) to tune $E_j$ or enlarging the capacitor area to lower $E_c$ are valid ways to control the $E_j/E_c$ ratio.\nThe image above shows the ratio between the energy levels with respect to the ground state energy as a function of noise charge. It is evident that with low values of $E_j/E_c$ small variations of $n_g$ lead to catastrophical change in energy differences. When $E_j/E_c$ is in the $20-80$ range the qubit is said to be in transmon regime and sensitivity to charge fluctuations is almost completely supressed. Notice that also the anharmonicity in the transition is lowered with higher values of $E_j/E_c$ but in a slower way so that the qubit is still regardable as a quantum anharmonic oscillator.\nBy being in transmon regime, neglecting so the noise charge term in the Hamiltonian, and by expressing the energy with creation and annihilation operators, this final form is found:\n$\\hat{H} = \\hbar w_q \\hat{b}^\\dagger \\hat{b} - E_c/\\hat{b}^\\dagger\\hat{b}^\\dagger \\hat{b}\\hat{b}$\nwhere $\\hbar w_q = \\sqrt{8 E_c E_j} - E_c$ is the corrected transmon frequency and refers to the first energy transition in the spectrum.\nTechnological implementation # The Jaynes - Cummings model # Now that we have built our atom, there are some important problems to be solved: how can we control the quantum state without disrupting it? How can we perform the projective measurements? Before talking about this, we have to make a step back, using a parallelism to understand better our physical system.\nWe know that, if we transmit a laser beam towards an atom at the right frequency, we can excite its state, by promoting the orbiting electron to an higher energetic level.\nThis model is described by the so-called Jaynes - Cummings hamiltonian:\n$$ \\begin{aligned} \\hat H_{JC} = \\omega_r \\hat a^\\dagger \\hat a + \\frac{\\omega_{01}}{2} \\hat\\sigma_z + g (\\hat a^\\dagger \\hat\\sigma_- + \\hat a \\hat\\sigma_+) \\end{aligned} $$\nThe light-matter interaction is well described into the third element:\nthe de-excitation of the atom brings the creation of a photon \u0026ldquo;sacrificing\u0026rdquo; a photon means to excite the atom This atomic level control can be well performed inside an optic resonator.\nA resonator is a structure that is able to select certain wave frequencies to resonate in a system. For example, take a guitar: its strings emits certain notes because we select a certain length, by pressing the strings on its surface.\nA notorious example in physics is the Fabry - Perot cavity, used for building lasers: if we put two mirrors in front of each other at a certain distance, only few frequencies of electromagnetic waves will oscillate between them. Putting an atom inside the Febry - Perot cavity permits us to control it using certain frequencies.\nLet\u0026rsquo;s do the same for our transmon qubit: if we put it inside a resonator made of superconducting transmission lines, we\u0026rsquo;ll be able to control or measure it.\nTo prove this, let\u0026rsquo;s examine the equivalent circuit of this system, to derive its hamiltonian. The technique of studying quantum systems by analyzing its equivalent circuit is called Circuit Quantum Electrodynamics (QED).\nThe derivation of this circuit is straightforward:\nthe resonator is represented by an harmonic oscillator (LC circuit) the qubit is represented by an anharmonic oscillator (JJ + C circuit) the coupling between the two is represented by a capacitance ($C_g$) The hamiltonian corresponding to this circuit is:\n$$ \\begin{aligned} \\hat H = (\\frac{\\hat Q^2_r}{2C_r} +\\frac{\\hat \\Phi ^2_r}{ 2 L_r}) + (4 E_c \\hat n^2 - E_j cos \\hat \\phi) \\end{aligned} $$\nthat, with some approximations, is equivalent to the Jayes - Cummings model.\nSo, we can control the information stored into a qubit with electromagnetic waves as we can control an atom with a laser! Cool, right?\nThe dispersive regime # Now that our model is ready to be used, there is an important problem to solve: how can we modify the state of the qubit without disrupting it?\nWe know from the basilar concepts of quantum physics that entering in contact with a quantum system brings its collapse, but we still need to find a way to modify its information and to create a useful computer.\nThe solution here is achieved in the Dispersive regime: the main idea is to use two different frequencies, one for control ($\\omega_{01}$)and one for readout ($\\omega_r$), in order to make two distinguished operations on the qubit.\nIf we choose these two frequencies such that:\n$$ \\begin{aligned} \\Delta = | \\omega_{q}-\\omega_r| \u0026raquo; g \\end{aligned} $$\nthe Jaynes - Cummings hamiltonian can be approximated to: $$ \\hat H_{disp} = (\\omega_r + \\chi \\hat \\sigma_z) \\hat a^\\dagger \\hat a + \\frac{\\omega_{q}}{2}\\hat \\sigma_z $$\n(with $\\chi \\approx \\frac{g^2}{\\Delta} $).\nThis has two direct consequences:\nif $\\sigma_z$ eigenvalue is +1 (the qubit is in excited state), the resonance frequency of the resonator will become $\\omega_r + \\chi$\nif $\\sigma_z$ eigenvalue is -1 (the qubit is in ground state), the resonance frequency of the resonator will become $\\omega_r - \\chi$\nThis means that the qubit state affects the system around it.\nAs we can appreciate from this image, $\\omega_q$ and $\\omega_r$ are distant from each other! It seems like measurement and control are two very different things\u0026hellip;\nIt\u0026rsquo;s time to use this system!\nmeasurement: probe the resonator at frequency $\\omega_r$; depending on the qubit state, the transmission frequency will be at $\\omega_r + \\chi$ or $\\omega_r - \\chi$ control: probe the resonator at $\\omega_q$ with the waveform you need to rotate the state of the qubit Qubit control # But what do we exactly mean with \u0026ldquo;qubit state rotation\u0026rdquo;? How is it possible to do that with resonating frequencies?\nBefore talking about that, we need to make a brief recap about an important topic in signal analysis: the I/Q modulation.\nA signal (a general waveform, like a sinusoidal wafe) can be decomposed into two additive components:\nan In-Phase (I) signal, which will have zero phase a Quadrature (Q) signal, with $\\frac{\\pi}{2}$ phase A fixed - frequency signal can also be represented as a dot in a complex plane, whose axis label the I and Q components that constitute it.\nUsing again the QED technique, we derive the hamiltonian of the driving voltage and controlled qubit system:\n$$ \\begin{aligned} \\hat H_d = \\Omega V_0 s(t) (I \\sigma_x + Q \\sigma_y) \\end{aligned} $$\nwhere:\n$\\Omega = \\frac{C_d}{C_\\Sigma} Q_0$ (equivalent circuit related constant) $V_0$ is the generated voltage amplitude $s(t)$ is the signal waveform The main idea is to modulate I and Q components of the driving signal in order to select a qubit x or y rotation.\nSo we mainly have two cases:\nif Q = 0, we will achieve the rotation around the x axis if I = 0, we will achieve the rotation around the y axis The z rotation case is different; indeed, the z gate is said to be virtual, since we cannot perform a direct z rotation, but only adjust the signal phase in order to transform its I and Q components:\n$I\u0026rsquo; = I \\cos \\phi - Q \\sin \\phi $\n$Q\u0026rsquo; = I \\sin \\phi - Q \\cos \\phi $\nIn all 3 cases, the rotation angle is bound to the duration of the driving signal.\nThat\u0026rsquo;s all, folks! # So, with this article, we explained you:\nwhat is superconductivity; what is a transmon qubit; the first building stages of a superconductive quantum computer. If you liked this article, please share it with other Quantum-enthusiasts!\n","date":"28 April 2025","externalUrl":null,"permalink":"/en/articles/hardware_superconducting_qubits_08_05_2025_gvpgje/superconducting-qubits/","section":"Articles","summary":"Introduction about the physics of superconductivity, the construction of a transmon qubit and the manipulation of information in a superconducting quantum computer","title":"Superconducting qubits","type":"articles"},{"content":" 🇨🇭 ETH Zurich Quantum Hackathon 2025 Six of our students competed against their brilliant international colleagues at ETH Zurich. Divided into two teams, they tackled the \u0026#34;Portfolio Optimization\u0026#34; challenge presented by QCentroid and the \u0026#34;Gate Parallelization\u0026#34; challenge by QuEra. Upon returning to Turin, they presented their solutions to fellow colleagues, professors, and quantum computing enthusiasts.\n🚀 Orientation Fair 2025 Second participation at the Orientation Fair, meeting new students interested in quantum physics.\n🔢 Pi Day 2025 Celebrating Pi Day with a quantum perspective, exploring the role of π in theoretical physics and quantum mechanics.\n🇩🇪 Pushquantum Hackathon 2024 Participation in the international hackathon at the TUM Entrepreneurship Research Institute in Munich.\n🧠 Internal Hackathon Fall 2025 Second internal hackathon focused on Quantum Optimization and Quantum Machine Learning, featuring original projects and exploration of new application horizons.\n🎤 DevFestAlps 2024 2024 Second participation at Google DevFestAlps with a new talk, sharing our passion for quantum computing.\n🌍 ETH Quantum Hackathon 2024 2024 Our first international hackathon at ETH Zurich. We worked intensively for 24 hours on various challenges proposed by startups and companies.\n🎓 Orientation Fair 2024 2024 During Politecnico\u0026#39;s annual Orientation Fair, we introduced ourselves to curious and quantum-interested prospective students.\n✨ Exploring Quantum Opportunities 2023 Our first major outreach event at Politecnico di Torino in collaboration with BeQuantum. A great success with over 200 attendees in the room.\n🎤 DevFestAlps 2023 2023 On stage at Google DevFestAlps at Toolbox Coworking in Turin, we presented our work on Grover\u0026#39;s algorithm and quantum oracles.\nGoogle DevFestAlps 2023 🔍 Internal Hackathon Fall 2023 The team took on an internal challenge focused on developing Grover\u0026#39;s algorithm. Heterogeneously composed teams worked independently and competed against each other, recreating the authentic spirit of a hackathon.\n","externalUrl":null,"permalink":"/en/activities/","section":"Activities","summary":"🇨🇭 ETH Zurich Quantum Hackathon 2025 Six of our students competed against their brilliant international colleagues at ETH Zurich.","title":"Activities","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" Get in Touch with Us! We welcome collaboration opportunities and are eager to explore potential partnerships. If you’re interested in partnering with us or have any inquiries, please feel free to reach out. Send us an email! Our partners Main partner Follow Us Stay updated on our latest projects and events by following us on social media! Instagram Linkedin We Appreciate Your Support! Whether you have questions, suggestions, or just want to say hello, your input means the world to us. Thank you for being a part of our journey! ","externalUrl":null,"permalink":"/en/contacts/","section":"","summary":"Get in Touch with Us!","title":"Contacts","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/snippets/","section":"Snippets","summary":"","title":"Snippets","type":"snippets"},{"content":" Who We Are QubiTO was founded in 2023, inspired by the enthusiasm of students and professors at the Polytechnic of Turin for quantum physics and its contemporary, promising technological prospects. Together, united by a passion for this dynamism, we research and disseminate aspects of this fascinating world in its countless variations, leveraging our knowledge and skills by participating as a team in international hackathons.\nWith the inauguration of the first quantum computer at the Polytechnic, Spark IQM, we will finally begin to apply our theoretical knowledge to the realization of practical projects!\nOur team currently consists of six divisions that focus on internal insights related to defined technological areas, mostly oriented towards quantum computing:\nHardware This division deals with the practical functioning of the quantum computer, investigating the variety of physical systems used to encode quantum bits – qubits – and the electronic systems employed to control them. Special attention is given to superconducting technology, which is the basis of the new quantum computer at the Polytechnic, Spark IQM.\nDecoherence Physical systems that exhibit quantum properties are subject to natural relaxation that deteriorates these properties over time. This phenomenon is known as \u0026ldquo;decoherence\u0026rdquo; and its characterization is crucial to ensure the proper functioning of any quantum computer. The team division dedicated to the study of decoherence conducts research on the physical mechanisms contributing to the phenomenon and how to effectively limit it for quantum computing purposes.\nError Correction Where partial decoherence of the physical system or interference from control electronics corrupts the state of the qubit, the implementation of error correction algorithms allows for the recovery of its original value. Optimizing these algorithms is of critical importance, especially considering the operation of computers that are still not powerful enough. The division dedicated to error correction studies these algorithms in their significant differences compared to those widely used for classical computers.\nProgramming The basic operations that can be performed on qubits are called \u0026ldquo;gates\u0026rdquo;. Their appropriate combination ideally makes it possible to execute any operation that is already within the reach of a classical computer. The true power of qubits lies in the fact that many gates do not have a classical counterpart, allowing for complex computations to be performed exponentially faster in the most fortunate cases. The programming division studies how to combine gates to derive quantum algorithms that demonstrate greater execution speed compared to their classical counterparts.\nMathematical methods and communications The division dedicated to mathematical methods and communication shifts its focus from the implementation of the quantum computer to emphasize both the mathematical concepts essential for understanding various challenges, such as optimization problems, and the infrastructure required for the transfer of quantum information, specifically messages encoded as qubits. In addition to the focus on quantum networks and the study of quantum information, this division places significant importance on exploring quantum cryptography, a promising technology for securing confidential communications.\nDivulgation A sixth division is responsible for external outreach through QubiTO\u0026rsquo;s social media channels, managing the content of the website, and participating in events that engage the public, also delving into topics and applications of quantum physics that are more distant from quantum computing.\nAdditionally, a sub-division of programmers manages and improves the website.\n","externalUrl":null,"permalink":"/en/team/","section":"","summary":"Who We Are QubiTO was founded in 2023, inspired by the enthusiasm of students and professors at the Polytechnic of Turin for quantum physics and its contemporary, promising technological prospects.","title":"Team","type":"page"}]