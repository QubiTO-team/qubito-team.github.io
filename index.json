[{"content":" Questo è il primo articolo di una serie su Qiskit e partirà dalle basi. Nonostante ci siano molti video e articoli simili online, l\u0026rsquo;obiettivo di questa lezione è fornire ai nuovi studenti un primo approccio pratico all\u0026rsquo;argomento con - si spera - un buon equilibrio tra dettagli e facilità per un principiante. Dopo questa lezione dovresti essere in grado di iniziare a creare e simulare circuiti in Qiskit.\nConcetti preliminari # Nel caso tu non sia familiare con i circuiti quantistici e le porte, ti consiglio di dare un\u0026rsquo;occhiata a IBM Quantum Composer, Quirk quantum circuit simulator e Bloch sphere simulator. Questi strumenti sono un ottimo modo per familiarizzare con il mondo quantistico utilizzando un\u0026rsquo;interfaccia grafica.\nPrimi passi con Qiskit # Prima di scrivere codice da soli, possiamo provare a eseguire il codice presente nel composer per confermare che ciò che stavamo vedendo fosse effettivamente codice Qiskit. Guarda nel pannello di destra del composer e dovresti vedere del codice Python simile all\u0026rsquo;immagine seguente (potresti dover selezionare \u0026ldquo;Qiskit\u0026rdquo; dal menu a discesa se \u0026ldquo;OpenQASM 2.0\u0026rdquo; è già selezionato).\nSe non vuoi aprire il composer solamente per questo step, puoi copiare il codice qui sotto\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from numpy import pi qreg_q = QuantumRegister(2, \u0026#39;q\u0026#39;) creg_c = ClassicalRegister(2, \u0026#39;c\u0026#39;) circuit = QuantumCircuit(qreg_q, creg_c) circuit.h(qreg_q[0]) circuit.cx(qreg_q[0], qreg_q[1]) circuit.measure(qreg_q[0], creg_c[0]) circuit.measure(qreg_q[1], creg_c[1]) Se tutto ha funzionato correttamente, Jupyter dovrebbe dare il seguente output:\n\u0026lt;qiskit.circuit.instructionset.InstructionSet at 0x7f84d02584c0\u0026gt; Questo è un primo passo, ma ci piacerebbe vedere qualcosa di un po\u0026rsquo; più rappresentativo, come il disegno del circuito!\nPrima di vedere come disegnare i circuiti, analizziamo brevemente il codice sopra:\nLe prime due righe con from ... import ... servono per importare librerie Python che contengono le funzioni e le classi necessarie in seguito. Non preoccuparti troppo dei dettagli per ora, ricorda solo di includere ciò che è necessario prima di eseguire il codice.\nA questo punto possiamo iniziare con la creazione del circuito stesso; come primo passo creiamo un registro quantistico e uno classico. I registri sono collezioni di bit o qubit; se non hai esperienza con i computer classici, puoi vederli come un modo per raggruppare (q)bit che hanno un significato simile. Per fare un esempio, se stai cercando di creare un circuito che somma due numeri a 3 cifre A e B, potresti creare un registro regA con tre bit per memorizzare le cifre di A e fare lo stesso per B; in questo modo è più facile ricordare il significato di ciascun bit. Sebbene i registri siano utili quando si creano circuiti complessi, possono creare confusione con circuiti molto semplici come quelli in questo articolo; per questo motivo non li utilizzerò molto in seguito.\nLa cosa importante da ricordare è che un QuantumRegister è un array di qubit, quindi scrivere qreg_q[0] significa \u0026ldquo;prendere il primo qubit nel registro quantistico qreg_q\u0026rdquo;.\nOra possiamo procedere creando un circuito quantistico chiamato circuit che contiene 2 qubit (quelli in qreg_q) e 2 bit (quelli in creg_c).\nSe vogliamo iniziare ad aggiungere porte e operazioni al circuito, possiamo utilizzare la sintassi mostrata nelle righe seguenti. In questo esempio applichiamo una porta Hadamard (h) al primo qubit e poi una porta CNOT (cx) che è controllata dal primo qubit e ha come target il secondo qubit.\nInfine, misuriamo (measure) i due qubit salvando i risultati nei rispettivi bit classici.\nDisegnare un circuito # Ora che abbiamo un\u0026rsquo;idea di cosa fa il codice sopra, vogliamo vedere come appare nella realtà. È molto semplice: basta aggiungere la seguente riga al codice e rieseguirlo.\ncircuit.draw(output=\u0026#34;mpl\u0026#34;) # Possibili formati di output: None, mpl, latex Dovresti vedere un\u0026rsquo;immagine come la seguente, che corrisponde esattamente a quello che vedevamo nel composer!\nNota che potresti ricevere un errore se non hai alcune librerie richieste. Se ciò accade, prova a installare le librerie specificate nell\u0026rsquo;output oppure prova a rimuovere output=\u0026quot;mpl\u0026quot;; il risultato non sarà così elegante, ma dovrebbe funzionare senza problemi. Se hai ulteriori dubbi, puoi fare riferimento alla documentazione.\nCome trattare circuiti e gate più complessi # Con quanto abbiamo visto prima, dovresti essere in grado di creare circuiti di base, ma presto diventerà difficile creare algoritmi avanzati senza introdurre un paio di concetti in più. Come esempio, ci piacerebbe risolvere un problema semplice:\nCome possiamo creare una porta OR in un circuito quantistico?\nQuesta domanda potrebbe sembrare sciocca all\u0026rsquo;inizio: perché dovremmo preoccuparci di creare una porta classica in un circuito quantistico? Per il momento non è troppo importante e può essere vista semplicemente come un esercizio, ma se vuoi approfondire puoi studiare gli oracoli per l\u0026rsquo;algoritmo di Grover; per implementarli, le porte classiche sono estremamente utili!\nUn\u0026rsquo;altra domanda che potrebbe sorgere è: perché vogliamo creare la porta OR e non la AND? Semplicemente perché abbiamo già la versione quantistica della porta AND! jsi chiama porta Toffoli o controlled-controlled-not (ccx in Qiskit).\nEcco com\u0026rsquo;è fatta la porta Toffoli con la sua tabella della verità:\nPrima di tutto, notiamo che questa porta opera su 3 qubit e non su 2 come ci aspetteremmo; il motivo non è immediato. Per completare l\u0026rsquo;esercizio ti serve solo sapere che la porta Toffoli si comporta esattamente come una porta AND quando in input abbiamo $ C = |0\\rangle $; il risultato dell\u0026rsquo;AND sarà in $ C $ dopo l\u0026rsquo;applicazione della porta.\nPuoi verificare questa affermazione osservando che, se ignori le righe in cui $ C = |1\\rangle $, la tabella della verità della Toffoli diventa identica a quella dell\u0026rsquo;AND.\nLa ragione per cui il \u0026ldquo;quantum AND\u0026rdquo; richiede 3 qubit è che tutte le porte quantistiche devono essere reversibili, il che significa che, dato qualsiasi output della porta, deve essere possibile identificare in modo univoco l\u0026rsquo;input che l\u0026rsquo;ha generato. Ad esempio, guarda la tabella della verità della porta AND: se mi dici che l\u0026rsquo;output dell\u0026rsquo;AND è $ 0 $, non sarei in grado di sapere se l\u0026rsquo;input era 00, 01 o 10.\nA B A and B A or B 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 Torniamo alla domanda originale di creare la porta OR; abbiamo visto che abbiamo già l\u0026rsquo;AND, ma cosa ce ne facciamo? Prima di \u0026ldquo;invocare\u0026rdquo; teoremi, facciamo un paio di semplici passaggi logici e vediamo dove arriviamo:\nProviamo a completare la seguente tabella della verità in cui gli input sono stati \u0026ldquo;invertiti\u0026rdquo; rispetto alla precedente:\nnot A not B (not A) and (not B) not( (not A) and (not B) ) 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 1 Questa sembra una serie di operazioni arbitrarie, ma, se guardiamo l\u0026rsquo;ultima colonna, possiamo facilmente vedere che coincide con la colonna \u0026ldquo;OR\u0026rdquo; della prima tabella, il che significa che abbiamo creato la funzione \u0026ldquo;OR\u0026rdquo; utilizzando solo AND e NOT! Potremmo anche farlo formalmente usando la legge di De Morgan.\nOra abbiamo tutti gli ingredienti per procedere e creare la nostra prima porta personalizzata! Ma prima facciamo un riepilogo dei passaggi:\nVogliamo creare la porta OR su Qiskit partendo dalla porta AND (Toffoli) e dalla porta NOT (X). In Qiskit abbiamo già queste porte nella forma delle porte ccx e x. Utilizzando la legge di De Morgan (o i semplici passaggi sopra), abbiamo dimostrato la seguente equivalenza:\nA | B = !(!A \u0026amp; !B) oppure, se preferisci una notazione diversa:\n$$ A \\lor B \\equiv \\lnot (\\lnot A \\land \\lnot B) $$\nVediamo ora come convertire questa formula in un circuito quantistico: prima di tutto, sottolineiamo che i circuiti e le porte quantistiche, in Qiskit, possono essere utilizzati in modo intercambiabile. Ciò significa che possiamo creare un circuito quantistico come abbiamo fatto in precedenza e, successivamente, utilizzarlo come una singola porta. Vedremo più avanti come fare tutti i passaggi; per il momento concentriamoci sulla creazione di un circuito che implementi la porta OR, utilizzando la formula sopra.\nPer cominciare, abbiamo bisogno di un circuito con tre qubit: A e B, che sono gli input, e C, che conterrà l\u0026rsquo;output.\nqc = QuantumCircuit(3) Nota come, in questo caso, non ho utilizzato alcun registro ma ho semplicemente specificato il numero di qubit nei parametri di QuantumCircuit. Teniamo a mente che il primo qubit (cioè qc[0]) rappresenta A, il secondo rappresenta B e il terzo C.\nOra è solo una questione di vedere quale porta è applicata a quale qubit. Nella formula vediamo che abbiamo porte x (NOT) applicate sia a A che a B, quindi possiamo aggiungerle in Python come segue:\nqc.x(0) qc.x(1) Poi abbiamo una AND tra A e B; ricordati che la Toffoli (ccx) si comporta come una AND quando C (il target) è inizializzato a $ | 0 \\rangle $, quindi possiamo aggiungerlo come segue:\nqc.ccx(0, 1, 2) Infine, dobbiamo negare l\u0026rsquo;output (il primo NOT nella formula); poiché C è l\u0026rsquo;output, dobbiamo semplicemente aggiungere una porta x al terzo qubit:\nqc.x(2) Sembrerebbe di aver finito, vediamo come appare il circuito risultante a questo punto:\nQuesto circuito fornisce i risultati corretti ma ha un problema importante: cambia i valori dei suoi input! Guarda i primi 2 qubit, sono soggetti a una porta x e quindi il loro valore all\u0026rsquo;inizio è diverso da quello alla fine. Questo comportamento presenta dei problemi poiché ci impedisce di riutilizzare i valori originali di A e B.\nFortunatamente, risolvere il problema è molto semplice; dobbiamo solo applicare l\u0026rsquo;operazione inversa della porta x, che è\u0026hellip;\nla porta x stessa! (Negare una quantità due volte è come non fare nulla o, più formalmente, $ X \\cdot X = \\mathbb{I} $)\nQuindi, per risolvere il problema, basta aggiungere queste due righe:\nqc.x(0) qc.x(1) Il circuito finale per la OR è quindi:\nPer rendere il codice che abbiamo scritto più facile da usare in seguito (e per creare una vera porta), mettiamo tutto all\u0026rsquo;interno di una funzione che restituisce il circuito stesso:\ndef OR() -\u0026gt; QuantumCircuit: qc = QuantumCircuit(3) qc.barrier() qc.x(0) qc.x(1) qc.ccx(0, 1, 2) qc.x(0) qc.x(1) qc.x(2) qc.barrier() return qc In questo modo, quando avremo bisogno di utilizzare la porta OR in Qiskit, dovremo semplicemente chiamare questa funzione.\nNota che ho anche aggiunto due barrier all\u0026rsquo;inizio e alla fine della porta; le barriere non sono porte, ma sono semplicemente \u0026ldquo;linee verticali\u0026rdquo; che rendono più facile delimitare visivamente le cose quando si disegna il circuito (vedi il disegno sopra).\nNota poi l\u0026rsquo;annotazione -\u0026gt; QuantumCircuit nella prima riga, questo è il modo in cui è possibile specificare il tipo dell\u0026rsquo;oggetto restituito dalla funzione in Python; non è obbligatorio aggiungerlo (infatti, se non lo metti, non cambierà nulla nell\u0026rsquo;esecuzione del codice), ma consente al tuo IDE (ad esempio, VSCode) di offrirti suggerimenti utili mentre scrivi il codice.\nComporre circuiti # Se vogliamo utilizzare la nuova porta che abbiamo creato all\u0026rsquo;interno di un circuito più grande, non possiamo semplicemente scrivere circuit.OR perché questa non è una porta \u0026ldquo;nativa\u0026rdquo; di Qiskit. Quello che dobbiamo fare è \u0026ldquo;attaccarla\u0026rdquo; (cioè comporla) a un circuito esistente. Vediamo come:\nqc = QuantumCircuit(3) qc.x(0) qc.compose(OR(), [0,1,2], inplace=True) qc.draw() Nelle righe sopra, abbiamo creato un circuito quantistico con 3 qubit, applicato una porta x al primo (solo come esempio) e poi attaccato la nostra porta OR con la funzione compose. Questa funzione richiede i seguenti parametri: il primo è il circuito che vogliamo attaccare (l\u0026rsquo;OR in questo caso), poi una lista dell\u0026rsquo;ordine in cui attaccare i qubit (cioè come \u0026ldquo;collegare i cavi\u0026rdquo;). Nella maggior parte dei casi vogliamo collegare il primo qubit del circuito al primo input della porta, il secondo al secondo e così via\u0026hellip; L\u0026rsquo;ultimo parametro inplace dovrebbe sempre essere impostato su True, altrimenti il circuito originale non verrà modificato.\nDisegnando il circuito otteniamo:\nBonus tip # Quando si lavora con circuiti complessi, è facile \u0026ldquo;perdersi\u0026rdquo; tra decine e decine di gate. Per ridurre la complessità del disegno, possiamo utilizzare il metodo to_instruction, che disegnerà il nostro sotto-circuito come una semplice scatola:\nbox_OR = OR().to_instruction(label=\u0026#39;OR\u0026#39;) qc = QuantumCircuit(3) qc.x(0) qc.compose(box_OR, [0,1,2], inplace=True) qc.draw(\u0026#39;mpl\u0026#39;) Se invece vogliamo ispezionare un circuito dopo averlo convertito in istruzioni, possiamo decomporlo così\nbox_OR = OR().to_instruction(label=\u0026#39;OR\u0026#39;) qc = QuantumCircuit(3) qc.x(0) qc.compose(box_OR, [0,1,2], inplace=True) qc.decompose().draw(\u0026#39;mpl\u0026#39;) Nota anche come, decompose ci mostra che la porta x in realtà viene implementata come una U3.\nSimulare un circuito quantistico # Ora siamo abbastanza bravi a creare circuiti, ma finora non ne abbiamo eseguito neanche uno. Vediamo come fare usando uno dei tanti modi possibili per simulare circuiti in Qiskit. Il metodo riportato qui esegue una simulazione ideale, cioè senza alcuna fonte di rumore, decoerenza e così via. Se desideri approfondire ulteriormente, puoi controllare la documentazione:\nhttps://qiskit.github.io/qiskit-aer/tutorials/1_aersimulator.html https://docs.quantum.ibm.com/guides/simulate-with-qiskit-aer Prima di continuare, importa le librerie necessarie (in aggiunta a quelle importate all\u0026rsquo;inizio)\nfrom qiskit import transpile from qiskit_aer import AerSimulator from qiskit.visualization import plot_histogram, plot_state_city Quando vogliamo eseguire una simulazione, abbiamo anche bisogno di alcuni bit classici per \u0026ldquo;salvare\u0026rdquo; i risultati delle misurazioni, quindi aggiungiamoli al circuito che vogliamo simulare. Possiamo farlo in due modi: manualmente (specificando i bit classici quando creiamo il circuito e poi utilizzandoli quando chiamiamo measure_all), oppure lasciando che la funzione measure_all li aggiunga per noi. Qui riporto entrambe le soluzioni, ma, nella maggior parte dei casi, la seconda strada è più conveniente.\nqc = QuantumCircuit(3, 3) qc.compose(OR(), inplace=True) qc.measure_all(add_bits=False) qc.draw(\u0026#39;mpl\u0026#39;) qc = QuantumCircuit(3) qc.compose(OR(), inplace=True) qc.measure_all() qc.draw(\u0026#39;mpl\u0026#39;) Ora siamo pronti per eseguire la simulazione. Dato che questo è un argomento piuttosto complesso da trattare in dettaglio, la seguente è solo una \u0026ldquo;ricetta\u0026rdquo; di base che può essere utilizzata in casi semplici. Per simulazioni più avanzate o per comprendere i vari passaggi, fai riferimento ai link sopra.\nsim = AerSimulator() transpiled_qc = transpile(qc, sim) result = sim.run(transpiled_qc).result() counts = result.get_counts(transpiled_qc) plot_histogram(counts) Ciò che otteniamo è un istogramma simile al seguente:\nPoiché il circuito è semplicemente una porta OR con i due input impostati su 0, vediamo che tutti i qubit (i due input e l\u0026rsquo;output) valgono su 0, poiché (0 | 0 = 0).\nProva a sperimentare con il circuito (ad esempio, aggiungendo porte x agli input) per vedere se la simulazione corrisponde alle tue aspettative.\nEsercizio finale # Per testare ciò che hai imparato, prova a implementare da solo un half adder. Potrebbe sembrare complesso all\u0026rsquo;inizio, ma alla fine dovrai solo unire i pezzi che hai già con funzioni che già conosci.\nSe hai bisogno di aiuto, qui sotto puoi trovare il codice per la porta XOR di cui potresti avere bisogno:\n## XOR circuit def XOR() -\u0026gt; QuantumCircuit: qc = QuantumCircuit(3) qc.cx(0, 2) qc.cx(1, 2) return qc ","date":"16 maggio 2025","externalUrl":null,"permalink":"/articles/introduzione-a-qiskit/","section":"Articoli","summary":"Questa breve guida spiega le basi di Qiskit, quanto serve per creare gate personalizzati e come eseguire la simulazione ideale di un circuito","title":"Introduzione a Qiskit","type":"articles"},{"content":" Classical Repetition Codes # Noise is a fundamental challenge in information processing systems. Many classical systems are able to avoid noise completely, while others must make use of error-correcting codes to protect against the effects of noise. The key idea is redundancy: by encoding messages with extra information, errors can be detected and corrected even if part of the data is corrupted. Repetition codes are extremely basic examples of error correcting codes.\nEncoding and Decoding Procedures # The core idea is to protect a bit against errors by repeating it multiple times. Consider the 3-bit repetition code, where a single bit is encoded as three identical bits.\n\\begin{aligned} 0 \u0026amp;\\mapsto 000\\\\ 1 \u0026amp;\\mapsto 111 \\end{aligned} In the absence of errors, the original bit can be trivially decoded. However, even if one bit flips, the original value can still be recovered by majority voting: the decoder outputs whichever value appears more frequently.\nabc \\mapsto majority(a,b,c) This corrects single-bit errors reliably.\nOf course, if 2 or 3 bits of the encoding flip, then the decoding won’t work properly and the wrong bit will be recovered, but if at most 1 of the 3 bits flips, the decoding will be correct. This shows a central concept in error correction: the trade-off between redundancy and robustness.\nError Analysis in Binary Symmetric Channels # As an example, suppose we wish to communicate a single bit to a hypothetical receiver through a classical noisy channel. The effect of the noise in the channel is to flip a transmitted bit with probability $p$, while with probability $1-p$ the bit is transmitted correctly. Such a channel is known as a binary symmetric channel, it flips each bit sent through it independently.\nIn this context, if we choose not to use any error correcting code and simply send whatever bit through the channel, the receiver will receive the wrong bit with probability $p$.\nOn the other hand, if we first use the 3-bit repetition code to encode the bit and then send each of the resulting three bits through the channel, each one of them will flip indipendently with probability $p$. The receiver will decode correctly only if at most one bit flips during the communication. So the probability of an error after the decoding corresponds to the probability that either two or each of the three bits flip during transmission. The total probability of an error is therefore\n3p^2(1-p)+p^3 = 3p^2-2p^3. Proposed addition by Edo\nThis can be obtained using probability theory. Suppose we denote with\np(X_1 \\cap X_2 \\cap X_3) the probability that when we obtain the 3-digit bit string, we obtain the result $X_i$ for the $i$-th bit, where the outcome can be $C_i$ for correct detection and $W_i$ for a wrong one.\nLet’s consider the case where all three bits are wrong. Since the three events are independent (we assumed this at the beginning), the theory tells us that the probability of the intersection of the events is the product of the probabilities of the single events,\np(W_1 \\cap W_2 \\cap W_3) = p(W_1) p(W_2) p(W_3) = p^3\\,. Analyzing the other case, we see that one possible scenario is the following:\np(C_1 \\cap W_2 \\cap W_3) = p(C_1) p(W_2) p(W_3) = (1-p)p^2\\,. But this can also occur (with the same calculation):\np(W_1 \\cap C_2 \\cap W_3) = (1-p)p^2\\,, and\np(W_1 \\cap W_2 \\cap C_3) = (1-p)p^2\\,. The final expression for the event of only one correct bit is\np\\big((C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big)\\,. Since the three composite events considered have an empty intersection (a bit cannot be simultaneously correct and wrong), the theory tells us that we can simply sum the single probabilities,\n\\begin{aligned} p\u0026amp; \\big((C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big) = \\\\ \u0026amp;= p(C_1 \\cap W_2 \\cap W_3) + p(W_1 \\cap C_2 \\cap W_3) + p(W_1 \\cap W_2 \\cap C_3) = \\\\ \u0026amp;=3(1-p)p^2\\,. \\end{aligned} Finally, we have to consider the composite event of all errors or only one correct bit. Since those have an empty intersection, we end up with\n\\begin{aligned} p\u0026amp;\\Big( \\big( (C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big) \\cup (W_1 \\cap W_2 \\cap W_3) \\Big) = \\\\ \u0026amp;= p^3 +3(1-p)p^2 =3p^2 -2p^3\\,. \\end{aligned} Binary Symmetric Error As can be seen in Fig. 1, when the error probability $p$ is less than $1/2$, the repetition code effectively reduces the chance of the receiver obtaining an incorrect bit. Conversely, if $p$ exceeds $1/2$, the code amplifies the likelihood of decoding errors rather than correcting them.\nQuantum Repetition Codes for Qubits # The 3-bit repetition code can be used also for qubit error correction.\nEncoding Quantum States # To create a 3-qubit repeated entangled state, we can use the circuit shown in Fig. 2. Thanks to this circuit we can encode the generic state $\\alpha \\ket{0}+ \\beta \\ket{1}$ into the state $\\alpha \\ket{000}+ \\beta \\ket{111}$, thanks to the action of the controlled NOT (CNOT) gates.\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n3-qubit bit flip code circuit diagram. Notice that this encoding is different from the repetition of the same state three times $\\ket{\\psi}\\otimes\\ket{\\psi}\\otimes\\ket{\\psi}$, which would be impossible due to the no cloning theorem.\nDetecting and Correcting Bit-Flip Errors # The first type of error we can correct with repetition qubits is the bit flip. This sort of error is represented as an $X$ gate. If one of the three qubits, say the middle one, undergoes this type of error, the final state of the system would be $\\alpha \\ket{010}+ \\beta \\ket{101}$. In order to detect this bit flip we could measure the state, but this would destroy the superposition.\nProposed addition by Edo\nHow can we try to understand which of the three qubits flipped without measuring directly the state? The correct way to do this is add a new piece to our system. This should be a system that start decoupled from our system, enter in contact with the main state and get influenced by it in a predictable way, but end up again in a decoupled state at the end. When i speak about decoupled i really refer, in a formal way, to what is called a separable state. The main property of a separable state is that if we measure one of the separated portion of our system we don’t perturb the rest. So we can exploit this property to deduce, measuring the new system, which of the three bits flipped ( assuming we have only a single flip). Then we can apply the inverse $X$ gate, so $X$ itself, to the wrong qubit to get again the initial state.\nThis cleared, and recalling that with $n$ qubit we can obtain $2^n$ different measurements, we need only 2 qubits that can index the $2^2 = 4$ different outcomes:\n00 if we have no errors;\n01 if the bit with error is the third one;\n10 if the bit with error is the first one;\n11 if the bit with error is the second one.\nNow, let’s see how can we design a circuit that is respecting all the premises. Consider our starting state as\n\\alpha \\ket{000} + \\beta \\ket{111}. For example, if an error occurs on the first qubit, we end up with the state\n\\alpha \\ket{100} + \\beta \\ket{011}. Now, we can try to use some gates, such as C-NOTs, to make this change affect the bottom two qubits. We can do this as shown in the following figure.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp; \u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nApplying that CNOT, denoted as $\\text{CX}_{i \\to j}$, meaning that the control qubit is the $i$-th one, we end up with\n\\begin{gathered} \\text{CX}_{1 \\to 4} \\big( (\\alpha \\ket{100} +\\beta \\ket{011} ) \\otimes \\ket{00} \\big) = \\\\ = \\text{CX}_{1 \\to 4} (\\alpha \\ket{100} \\otimes \\ket{00} ) + \\text{CX}_{1 \\to 4} (\\beta \\ket{011} \\otimes \\ket{00}) = \\\\ = \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{00} \\end{gathered} where we exploited linearity in the second step. We notice that the CNOT acted only on the first part of our superposition state. This is not a state we want to obtain in the end because it is not separable, so we cannot put it in a form like\n\\begin{gathered} (\\alpha \\ket{100}+ \\beta \\ket{011} ) \\otimes \\ket{10} \\end{gathered} That is the state we would like to obtain since we want to measure the last two qubits and obtain the string $10$, which tells us that the error occurred on the first qubit, all without perturbing our original state (the first three qubits).\nSo we need to modify the second part of the state, the one linked to the coefficient $\\beta$, to end up with $\\beta \\ket{011} \\otimes \\ket{10}$. How can we do this? Since the $\\alpha$ term has the first qubit set to $1$, we can apply a CNOT to the second or the third qubit without modifying that part of the state. So we can apply the CNOT to the second one, for example.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp; \u0026amp; \u0026amp; \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; \u0026amp; \u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; \u0026amp; \u0026amp;\u0026amp;\nIn this way, we can obtain, by applying the gate:\n\\begin{gathered} \\text{CX}_{2 \\to 4} \\big( \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{00} \\big) = \\\\ = \\text{CX}_{2 \\to 4} (\\alpha \\ket{100} \\otimes \\ket{10}) + \\text{CX}_{2 \\to 4} (\\beta \\ket{011} \\otimes \\ket{00}) = \\\\ = \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{10} = \\\\ = \\big( \\alpha \\ket{100} + \\beta \\ket{011} \\big)\\otimes \\ket{10} \\end{gathered} that is the state we want to get.\n\u0026amp;\u0026amp;\u0026amp; \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp;\n\u0026amp;\u0026amp;\u0026amp; \u0026amp; \u0026amp; \u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; \u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; \u0026amp;\nIf we now consider an error on the third qubit, resulting in a state like\n\\alpha \\ket{001} + \\beta \\ket{110}, we see that our circuit is not working correctly. In fact,\n\\begin{gathered} \\text{CX}_{2 \\to 4} \\text{CX}_{1 \\to 4} \\big( (\\alpha \\ket{001} + \\beta \\ket{110} ) \\otimes \\ket{00} \\big) = \\\\ = \\text{CX}_{2 \\to 4} \\text{CX}_{1 \\to 4} (\\alpha \\ket{001} \\otimes \\ket{00} ) + \\text{CX}_{2 \\to 4} \\text{CX}_{1 \\to 4} (\\beta \\ket{110} \\otimes \\ket{00}) = \\\\ = \\alpha \\ket{001} \\otimes \\ket{00} + \\beta \\ket{110} \\otimes \\ket{00} = \\\\ = \\big( \\alpha \\ket{001} + \\beta \\ket{110} \\big) \\otimes \\ket{00}. \\end{gathered} Notice that in this case, the CNOT acting on the first term of the superposition (the $\\alpha$ term) does nothing, while the second term results in two consecutive flips that cancel each other out. So here, the action of the gates is equivalent to the identity. We end up with no information about the error. We can correct this situation by adding CNOTs; like in the previous situation, we need to add two of them to create a separable state.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp; \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nIn this way, we end up with the result $01$ if we have an error on the third bit. Remember that the first two CNOTs act like the identity in this situation.\nIf we return to the previous case, the one with the error on the first qubit, we see that the situation is symmetric: the two gates we added at the end act like the identity, while the first two act as we described previously; everything still works. Moreover, this circuit acts on the no-error state as the identity.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp; \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nThe last case we need to investigate is the error on the central qubit. We want, in this case, to obtain the result $11$. Let’s see what happens with the current circuit. We notice that the first and the last CNOTs act only on the $\\beta$ part of the superposition. The middle ones, instead, act only on the $\\alpha$ part. If we check, we end up with the separable state of the desired type:\n\\big( \\alpha\\ket{010}+\\beta\\ket{101} \\big) \\otimes \\ket{11}. To prevent that we can add two ancilla qubits, which will be measured to reveal if and on which qubit the error happened. This is easily done by adding four extra CNOT gates, see Fig. 3.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nWe can easily compute the measurement outcomes (syndromes) for all the states obtained from at most one bit-flip, they are listed in the following table.\nState Syndrome $\\alpha \\ket{000}+ \\beta \\ket{111}$ 00 $\\alpha \\ket{100}+ \\beta \\ket{011}$ 10 $\\alpha \\ket{010}+ \\beta \\ket{101}$ 11 $\\alpha \\ket{001}+ \\beta \\ket{110}$ 01 It is important to underline that perfect bit-flip errors are just a simple model of a much more complex phenomenon, here we easily assumed one flip represented by a unitary operator. We will discuss about non unitary errors by the end of the article.\nHandling Phase-Flip Errors # Another fundamental type of errors we have to worry about are phase-flip errors, modeled as $Z$ gates. Applying a $Z$ gate to any of the three qubits of the previous encoding we obtain\n(\\mathbb{I}\\otimes Z \\otimes \\mathbb{I})(\\alpha \\ket{000}+ \\beta \\ket{111})=\\alpha \\ket{000}- \\beta \\ket{111}. It turns out that phase-flips on any of the three qubits have the same effect on the whole final state, leading to a total phase flip for an odd number of $Z$ gates applied. Unfortunately our previous error correction circuit is not able to detect phase-flip errors, the output in the ancilla qubits will be $00$ anyway, not detecting any error.\nModified Repetition Code for Phase-Flip Mitigation # In order to detect phase flip errors, we must modify the encoded state $\\alpha \\ket{000}+ \\beta \\ket{111}$ by applying three Hadamard gates, reaching then the state $\\alpha \\ket{+++}+ \\beta \\ket{---}$. This is done by the circuit in Fig. 4.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n3-qubit phase flip code circuit diagram. After this encoding, a phase-flip error will transform a $\\ket{+}$ state in a $\\ket{-}$ and viceversa. So adding two ancilla qubits in $\\ket{+}$ state, we will be able to reproduce a circuit analogous to the one done for bit-flips, represented in Fig. 5.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nAs before the measured syndorme will tell us if and where the error occurred.\nCorrecting phase-flip errors force us to a change of basis, done by means of Hadamard gates.\nThe 9-Qubit Shor Code # The 9-qubit Shor error correcting code is a obtained combining the 3-bit repetition code for bit-flip and phase-flip errors described before.\nCode Structure and Encoding # The two error correcting codes just seen will be concatenated, resulting so in a 9-qubits circuit in the end. These two codes can be applied in both orders, so we made the choice to apply first the phase-flip error correcting code (outer code), the resulting qubits will be then encoded using the 3-bit repetition code for bit-flip errors (inner code), as in Fig. 6.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n9-qubit Shor code circuit diagram. In this way, the resultant action of the circuit on the original qubit basis states is the following:\n\\begin{aligned} \\ket{0} \u0026amp;\\mapsto \\frac{1}{2\\sqrt{2}}(\\ket{000}+\\ket{111})\\otimes(\\ket{000}+\\ket{111})\\otimes(\\ket{000}+\\ket{111}) \\\\ \\ket{1} \u0026amp;\\mapsto \\frac{1}{2\\sqrt{2}}(\\ket{000}-\\ket{111})\\otimes(\\ket{000}-\\ket{111})\\otimes(\\ket{000}-\\ket{111}). \\end{aligned} Error Propagation and CNOT Gate Operations # Now before going and see how errors affect our encoding, we must stop to introduce some important relationships and equivalences regarding $X$ and $Z$ errors. The following equivalences can be verified calculating the matrix multiplications or by writing down the truth tables.\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n= \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n= \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n= \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\nX gates and CNOT gates relationships. \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n= \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n= \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\n= \u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\nZ gates and CNOT gates relationships. Correction of Bit-Flip Errors # Considering a bit-flip error affecting our circuit, we can focus on each of the three blocks separately. It is easy to see that each of them is the encoding of a single qubit using the 3-bit repetition code for bit-flip errors, so exploiting two ancilla qubit per block we can measure and correct up to one bit-flip error per block.\nCorrection of Phase-Flip Errors # Since the code designed to correct phase-flips is not affected directly by the errors, showing the capabilities of the Shor code to detect this kind of errors will be more difficult given our order of encoding.\nSupposing a $Z$ error affecting one of the 9 qubits, we can use the equivalences introduced before to show that it is equivalent to one phase-flip error occurring prior the inner encoding, see Fig. 9.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n=\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n=\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nSo a $Z$ error occurring in any of the three qubits within a block has the same effect on the final state of a $Z$ error occurring before the inner code.\nWhat we can do to deal with phase-flip errors is to model the $Z$ error as happening before the inner code; so decode the former to go back to the first stage of encoding. Now our original qubit is just encoded using the repetition code for phase-flips. In this way we can just use two ancilla qubits as before to check the correctness of our state, and then encode again each of the three qubits with the bit-flip code. The syndrome will detect the block in which the phase flip occurred, see Fig.10.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nIn the end we can simplify the previous circuit using four CNOT gates less, as in Fig.11.\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\nSimultaneous Bit and Phase-Flip Error Correction # We’ve just seen how both $X$ and $Z$ errors can be detected and corrected using the Shor code. Let’s now consider the scenario in which both a bit-flip and a phase-flip error happen simultaneously, possibly on the same qubit; we’ll see that the Shor code is able to handle this scenario without further modifications.\nSince $X$ and $Z$ errors matrices anticommute:\nXZ = \\begin{pmatrix}0\u0026amp;1\\\\1\u0026amp;0\\end{pmatrix} \\begin{pmatrix}1\u0026amp;0\\\\0\u0026amp;-1\\end{pmatrix}= \\begin{pmatrix}0\u0026amp;-1\\\\1\u0026amp;0\\end{pmatrix}=-\\begin{pmatrix}1\u0026amp;0\\\\0\u0026amp;-1\\end{pmatrix}\\begin{pmatrix}0\u0026amp;1\\\\1\u0026amp;0\\end{pmatrix}=-ZX inverting them just causes an irrilevant global phase factor of $-1$. So, no matter in which order the errors occur, we are always able to propagate the $Z$ error prior to the inner code. At this point it is important to notice that the procedures to detect and eventually correct bit-flip and phase-flip errors can be performed indipendently introducing enough ancilla qubits, so we can simply first apply the procedure to detect the $X$ error, and then apply the procedure to detect the $Z$ error to finally recover the correct initial state. To be precise it is not important at all the order in which the procedures are performed, since $X$ gates on any of the nine qubits of the encoding commute with all the gates of the simplified circuit to correct phase-flip errors (Fig. 11); so also inverting the order of the procedures will correctly detect both the errors.\nRobustness Against Random Errors # Before considering arbitrary quantum errors, let’s analyze the performance of the 9-qubit Shor code when random errors rapresented by Pauli matrices occur on the qubits.\nLet’s consider a simple noise model where each qubit experiences an error with probability $p$, the errors occur indipendently. To keep things simple we analyze the worst case scenario\nConsider a scenario where errors strike qubits independently with probability $p$, analogous to the binary symmetric channel in classical systems. For simplicity, assume no correlations between errors. While distinct probabilities could be assigned to $X$, $Y$, and $Z$ errors, we focus on the worst-case scenario for the Shor code: $Y$ errors. Since $Y$ errors are equivalent to simultaneous $X$ and $Z$ errors up to a global phase factor, them represents both bit-flip and phase-flip errors.\nSuppose we encode a logical qubit using the Shor code, whether we get an advantage or not depends on the error probability $p$. Similar to the classical 3-bit repetition code, which becomes disadvantageous when $p\u0026gt;1/2$, also for the Shor code we can find such a threshold and quantify its performance.\nThe 9-qubit Shor code is able to correct any Pauli error on a single qubit, including so $Y$ errors, but it fails if more then one $Y$ error occur on different qubits. Since in our scenario we focus on $Y$ errors, the code is reliable and protects our logical qubit as long as at most one of the physical qubits is affected by an error, which happens with probability\n(1-p)^9 + 9p(1-p)^8. Otherwise, the code fails with probability\n1-(1-p)^9-9p(1-p)^8. Is not sure that the happening of more then one Pauli error lead to wrong decoding of the original qubit state, but for the sake of this analysis we consider this scenario as a failure. We say in this case a logical error affected our logical qubit. On the other hand, if we do not use the code our single physical qubit suffers logical errors with probability $p$, so the code gives a real advantage only for $p$ such that\n1-(1-p)^9-9p(1-p)^8\u0026lt;p. As we can see in Fig. 12 the threshold for the 9-qubit Shor code is about $0.0323$. If $p$ is smaller of the former value, the code is helping, it has diminished the likelihood of an error to occur, but if $p$ is greater then the threshold, we should not use the code since it would worsen the robustness to noise of our system w.r.t a single physical qubit.\nError Discretization in Quantum Systems # The 9-qubit Shor code corrects arbitrary quantum errors—not just $X$ or $Z$ errors—by leveraging its ability to correct $X$ and $Z$ errors separately. This works because any possible single-qubit error can be decomposed into a combination of $X$, $Z$, or both (a property known as the discretization of errors). Since the code detects and corrects $X$ and $Z$ errors independently, it inherently handles all other errors as well. Thus, no additional mechanisms are needed: correcting $X$ and $Z$ suffices to protect against arbitrary quantum noise. First we focus on Unitary Errors.\nModeling Unitary Qubit Errors # The 9-qubit Shor code can correct any single-qubit unitary error, even those that are not close to the identity (e.g., small rotations or arbitrary unitary operations). While it may seem challenging to correct infinitely many possible errors, the key insight is that any single-qubit unitary $U$ can be decomposed into a linear combination of Pauli operators:\nU = \\alpha I + \\beta X + \\gamma Y + \\delta Z where $Y = iXZ$.\nWhen an error $U_k$ occurs on the $k$-th qubit, the corrupted state becomes a superposition of the original state and states with $X_k$, $Z_k$, or $X_kZ_k$ errors. During error detection, the syndrome measurements probabilistically collapse this superposition into one of the Pauli error cases (or no error), with probabilities $|\\alpha|^2$, $|\\beta|^2$, $|\\gamma|^2$, and $|\\delta|^2$. The syndrome reveals which error occurred, allowing its correction. Remarkably, this process works even for tiny errors, as the syndrome measurements discretize the error into a Pauli operation, which the code is designed to fix. After correction, the system returns to the original encoded state, effectively removing the entropy introduced by the error. This demonstrates the discretization of errors: arbitrary unitary errors are reduced to correctable Pauli errors through syndrome measurement.\nThe 9-qubit Shor code corrects arbitrary unitary errors through error discretization. For multi-qubit errors, we formally represent operations using tensor products with identity matrices. Using Qiskit’s qubit numbering $(Q_8,Q_7,...,Q_0)$, single-qubit operations extend to the 9-qubit space as:\n\\begin{aligned} X_0 \u0026amp;= I^{\\otimes 8} \\otimes X = I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes X\\\\ Z_4 \u0026amp;= I^{\\otimes 4} \\otimes Z \\otimes I^{\\otimes 4}=I\\otimes I\\otimes I\\otimes I\\otimes Z \\otimes I\\otimes I\\otimes I\\otimes I \\\\ U_7 \u0026amp;= I \\otimes U \\otimes I^{\\otimes 7} =I\\otimes U\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I \\end{aligned} where $I^{\\otimes n}$ denotes an $n$-fold tensor product of identity matrices. An arbitrary unitary error $U_k$ on qubit $k$ decomposes into Pauli operators as:\nU_k = \\alpha I^{\\otimes 9} + \\beta X_k + \\gamma Y_k + \\delta Z_k with $X_k$, $Z_k$ defined similarly to [eq:errors], and $Y_k = iX_kZ_k$. For multiple errors, the formalism extends naturally:\nU_{j,k} = (I^{\\otimes (8-j)} \\otimes U_j \\otimes I^{\\otimes j}) \\cdot (I^{\\otimes (8-k)} \\otimes U_k \\otimes I^{\\otimes k}) The syndrome measurement projects these continuous errors onto discrete Pauli operators. For example, a two-qubit error $U_{2,5}$ would collapse to one of $I$, $X_2$, $Z_5$, $X_2Z_5$, etc., with probabilities determined by the decomposition coefficients. The tensor product structure ensures correct identification of affected qubits through the syndrome pattern.\n\\xi \\otimes \\ket{\\psi}\\bra{\\psi} where\n\\begin{aligned} \\xi \u0026amp;= |\\alpha|^2 \\ket{I \\text{ syndrome}}\\bra{I \\text{ syndrome}}\\\\ \u0026amp;+ |\\beta|^2 \\ket{X_k \\text{ syndrome}}\\bra{X_k \\text{ syndrome}}\\\\ \u0026amp;+ |\\gamma|^2 \\ket{X_kZ_k \\text{ syndrome}}\\bra{X_kZ_k \\text{ syndrome}}\\\\ \u0026amp;+ |\\delta|^2 \\ket{Z_k \\text{ syndrome}}\\bra{Z_k \\text{ syndrome}}. \\end{aligned} General Arbitrary Qubit Errors # We now examine arbitrary (not necessarily unitary) errors on qubits. Specifically, we model the error using a general quantum channel $\\Phi$, which could represent various noise processes—such as dephasing, depolarization, reset operations, or even unconventional, less-studied channels.\nTo analyze $\\Phi$, we first express it in terms of Kraus operators:\n\\Phi(\\sigma) = \\sum_j A_j \\sigma A_j^\\dagger, where each $A_j$ is a $2 \\times 2$ matrix. Since the Pauli matrices form a basis for such operators, we expand each $A_j$ as:\nA_j = \\alpha_j I + \\beta_j X + \\gamma_j Y + \\delta_j Z. This decomposition allows us to rewrite the action of $\\Phi$ on a target qubit $k$ in terms of Pauli errors:\n\\begin{aligned} \\Phi_k \\big( \\ket{\\psi}\\bra{\\psi} \\big) \u0026amp;= \\sum_j \\big( \\alpha_j I_k + \\beta_j X_k + \\gamma_j Y_k + \\delta_j Z_k \\big) \\ket{\\psi}\\bra{\\psi} \\\\ \u0026amp;\\quad \\times \\big( \\alpha_j I_k + \\beta_j X_k + \\gamma_j Y_k + \\delta_j Z_k \\big)^\\dagger. \\end{aligned} In essence, we have reformulated the Kraus operators as linear combinations of Pauli terms.\nUpon measuring the error syndrome and applying the appropriate correction, the resulting state resembles the unitary error case, albeit with a more complex mixture:\n\\xi \\otimes \\ket{\\psi}\\bra{\\psi}, where $\\xi$ now incorporates contributions from all Kraus terms:\n\\begin{aligned} \\xi \u0026amp;= \\sum_j \\Big( |\\alpha_j|^2 \\ket{I \\text{ syndrome}}\\bra{I \\text{ syndrome}} \\\\ \u0026amp;\\quad + |\\beta_j|^2 \\ket{X_k \\text{ syndrome}}\\bra{X_k \\text{ syndrome}} \\\\ \u0026amp;\\quad + |\\gamma_j|^2 \\ket{X_kZ_k \\text{ syndrome}}\\bra{X_kZ_k \\text{ syndrome}} \\\\ \u0026amp;\\quad + |\\delta_j|^2 \\ket{Z_k \\text{ syndrome}}\\bra{Z_k \\text{ syndrome}} \\Big). \\end{aligned} While the explicit derivation involves more terms, the underlying principle remains identical to the unitary scenario: syndrome extraction and correction project the error into distinguishable Pauli components.\nExtensions and Generalizations # The discretization of errors naturally extends to more general quantum error-correcting codes, including those capable of detecting and correcting errors across multiple qubits. In such scenarios, multi-qubit errors can be represented as tensor products of Pauli matrices:\nE = \\bigotimes_{k=1}^n P_k \\quad \\text{where} \\quad P_k \\in \\{I, X, Y, Z\\}, and distinct syndromes identify corresponding Pauli corrections that may need to be applied to multiple qubits simultaneously, rather than just a single qubit.\nThrough syndrome measurement, errors are effectively projected onto a discrete set of possibilities characterized by these Pauli tensor products. By applying the appropriate corrections, we can recover the original encoded state. The randomness introduced during this process is confined to the syndrome qubits, which are subsequently either discarded or reset. This mechanism effectively removes the generated randomness from the system containing the encoded information, preserving the integrity of the quantum computation.\nThe fundamental principle remains consistent with the single-qubit case: error correction proceeds by\nIdentifying error syndromes through measurement,\nDetermining the corresponding Pauli corrections, and\nIsolating the randomness in ancillary qubits that are then removed from the system.\nThis approach maintains the essential features of quantum error correction while scaling to more complex, multi-qubit error patterns.\n","date":"17 maggio 2025","externalUrl":null,"permalink":"/articles/quantum-error-correction/","section":"Articoli","summary":"Using techniques like repetition codes and the 9-qubit Shor code, quantum error correction enables reliable quantum computing by protecting qubits from bit-flip errors, phase-flip errors, and arbitrary errors.","title":"Quantum Error Correction","type":"articles"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/articles/","section":"Articoli","summary":"","title":"Articoli","type":"articles"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/","section":"Autori","summary":"","title":"Autori","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/edoardo-frulla/","section":"Autori","summary":"","title":"Edoardo Frulla","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/leonardo-niccolai/","section":"Autori","summary":"","title":"Leonardo Niccolai","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/mattia-placi/","section":"Autori","summary":"","title":"Mattia Placi","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/tags/qec/","section":"Tags","summary":"","title":"QEC","type":"tags"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/tags/qiskit/","section":"Tags","summary":"","title":"Qiskit","type":"tags"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/walid-bou-ezz/","section":"Autori","summary":"","title":"Walid Bou Ezz","type":"authors"},{"content":"","date":"16 maggio 2025","externalUrl":null,"permalink":"/authors/giacomo-bertelli/","section":"Autori","summary":"","title":"Giacomo Bertelli","type":"authors"},{"content":"","date":"16 maggio 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/authors/enrico-pavese/","section":"Autori","summary":"","title":"Enrico Pavese","type":"authors"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/authors/francesco-zanti/","section":"Autori","summary":"","title":"Francesco Zanti","type":"authors"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/authors/marc-helou/","section":"Autori","summary":"","title":"Marc Helou","type":"authors"},{"content":" Introduzione # In questa prima lezione, noi della divisione Hardware vi spiegheremo i primi concetti teorici alla base del funzionamento dei computer quantistici superconduttori. L\u0026rsquo;articolo è diviso in tre sezioni:\nnella prima, ci sarà una breve discussione sui concetti fondamentali della superconduttività; nella seconda, vi spiegheremo come codificare le informazioni utilizzando la superconduttività; infine, parleremo di come poter manipolare queste informazioni. Siete pronti? Iniziamo!\nFondamenti teorici della superconduttività # Nella ricerca di tecnologie di computer quantistici, i circuiti superconduttori sono emersi come una delle piattaforme più promettenti. Tra le varie architetture di qubit superconduttori, il qubit transmon si distingue per il suo equilibrio tra coerenza e scalabilità. Alla base di questo progetto c\u0026rsquo;è il fenomeno della superconduttività, uno stato quantistico macroscopico che permette la creazione di elementi circuitali come le giunzioni Josephson, componenti essenziali per le operazioni transmon. Per comprendere appieno i principi alla base dei qubit transmon, occorre innanzitutto capire la fisica fondamentale della superconduttività.\nSuperconduttività # Conduzione senza perdite ed effetto Meissner # La superconduttività è uno stato in cui un materiale presenta una resistenza elettrica nulla al di sotto di una temperatura critica $T_c$. Questa conduzione senza perdite non è semplicemente un\u0026rsquo;estensione della conduttività ideale, ma piuttosto una manifestazione di una nuova fase quantistica della materia. Inoltre, i superconduttori espellono i campi magnetici dal loro interno (effetto Meissner), una caratteristica distintiva che li differenzia dai conduttori perfetti.\nQuantità critiche # Un materiale superconduttore passa allo stato normale (resistivo) quando è sottoposto a:\nTemperature superiori a $T_c$ Campi magnetici superiori al campo magnetico critico $H_c (T)$ Correnti superiori a una corrente critica $I_c$ La dipendenza dalla temperatura del campo critico è data dalla legge empirica:\n$$ \\begin{aligned} H = H_{c_0} \\cdot \\left(1 - \\left(\\frac{T}{T_{c}}\\right)^2 \\right) \\end{aligned} $$\ne secondo la legge di Ampère, questo campo critico è correlato alla massima corrente sostenibile dal materiale, che è: $I_c = 2 \\pi R H_c$\nPortatori di carica nei superconduttori # Nello stato superconduttivo, gli elettroni di conduzione formano coppie legate note come coppie di Cooper, che si comportano come bosoni. I meccanismi di accoppiamento sono diversi, in questa sede ci occuperemo per semplicità dell\u0026rsquo;accoppiamento fonico, il più semplice - nondimeno l\u0026rsquo;unico analiticamente descritto dalla teoria BCS. Funziona così: quando un elettrone si muove nel reticolo, lo distorce a causa dell\u0026rsquo;attrazione coulombiana con gli ioni del reticolo, creando un potenziale positivo locale che attrae un altro elettrone.\nPoiché queste coppie hanno spin intero, non seguono il principio di esclusione di Pauli e possono condensarsi in un singolo stato quantistico, portando alla coerenza macroscopica della fase superconduttiva.\nFunzione d\u0026rsquo;onda macroscopica # Ogni coppia di Cooper contribuisce a uno stato quantico collettivo descritto da una funzione d\u0026rsquo;onda macroscopica:\n$\\Psi(r, t) = \\Psi_0 \\cdot e^{-j(\\omega t + \\phi)}$\nQuesta funzione d\u0026rsquo;onda viene estesa all\u0026rsquo;intero superconduttore e la sua fase $\\phi$ diventa un elemento chiave nella dinamica dei circuiti superconduttori, poiché è legata al campo magnetico esterno che agisce sulla giunzione, come vedremo tra poco.\nGiunzione Josephson ed effetto Josephson # Una giunzione Josephson (JJ) è costituita da due superconduttori separati da un sottile strato isolante. A causa dell\u0026rsquo;effetto tunnel della funzione d\u0026rsquo;onda macroscopica, una supercorrente può fluire attraverso questo isolante, un fenomeno noto come effetto Josephson.\nÈ importante notare che non sono le singole coppie di Cooper, ma le funzioni d\u0026rsquo;onda macroscopiche a interferire e a consentire la corrente: $ I = I_c \\cdot \\sin(\\phi) $\nDove $\\phi = \\phi_2 - \\phi_1$ è la differenza di fase attraverso la giunzione, riferita alla fase delle due funzioni d\u0026rsquo;onda definite rispettivamente per i due lati superconduttori della JJ.\nQuesta relazione non lineare è responsabile del comportamento della JJ come induttore non lineare, con un\u0026rsquo;induttanza effettiva:\n$$ \\begin{aligned} L(\\phi) = \\frac{\\Phi_0}{2 \\pi I_c \\cos(\\phi)} \\end{aligned} $$\ncon\n$L_j = (\\Phi_0)/(2 \\pi I_c)$\ndefinita come induttanza di Josephson\n$\\Phi_0 = \\frac{h}{2e} \\approx 2,07 \\times 10^{-15} Wb$ è il quanto di flusso magnetico, cioè una costante che si riferisce ai più piccoli quanti di flusso magnetico che possiamo considerare.\nConsiderazioni sull\u0026rsquo;energia # La giunzione Josephson immagazzina energia come: $E(\\phi) = E_J \\cdot (1 - \\cos(\\phi))$\nDove: $E_J = \\frac{I_c \\Phi_0}{2 \\pi}$ è la energia Josephson. Questo valore è periodico rispetto alla differenza di fase definita sopra e può essere regolato da un campo magnetico esterno che agisce sulla JJ, come vedremo tra poco.\nRelazioni tensione-fase e flusso # Dalla relazione tra la tensione $V$ e la differenza di fase $\\phi$:\n$(d \\phi)/(d t) = (2 \\pi V)/(\\Phi_0) $\npossiamo definire la quantità di flusso elettrico $\\Phi$ come:\n$ \\Phi = \\int_0^t V(t\u0026rsquo;) d t\u0026rsquo; = \\frac{\\Phi_0}{2 \\pi}(\\phi - \\phi_0) $\nda cui possiamo esprimere $\\phi= 2\\pi \\Phi/(\\Phi_0) + \\phi_0$\nCiò rende la differenza di fase direttamente legata al flusso totale che agisce sulla JJ.\nQubit a superconduttore: dal Circuito LC al Transmon Qubit # Dopo aver dato uno sguardo alla fisica della superconduttività, vediamo come utilizzarla per costruire un\u0026rsquo;unità di informazione quantistica. Partendo da circuiti classici, costruiremo strutture in cui le coppie di Cooper sono utilizzate come portatrici di informazione grazie alla loro presenza.\nReview del Qubit # Cominceremo con un ripasso della basilare unità di informazione quantistica, il quantum bit o qubit. Nella teoria classica dell\u0026rsquo;informazione, l\u0026rsquo;unità di misura più elementare è il binary digit, o bit, che può assumere uno dei due valori 0 o 1. La sua controparte quantistica è il qubit che, grazie alla superposizione degli stati, un semplice risultato della matematica fondante della meccanica quantistica, può assumere valori pari a tutte le infinite combinazioni di 0 e 1. Fisicamente, un qubit è un sistema a due livelli che può essere manipolato e letto in modo diverso a seconda della tecnologia usata per implementarlo. Utilizzando la notazione di Dirac, possiamo definire un qubit come:\n$$ \\begin{aligned} \\Psi = \\alpha\\ket{0} + \\beta\\ket{1} \\end{aligned} $$\nDove $\\alpha$ e $\\beta$ sono numeri complessi che devono soddisfare la relazione:\n$|\\alpha|^2 + |\\beta|^2 = 1 $\nCircuiti LC e linee di trasmissione # Avendo in mente l\u0026rsquo;obbiettivo di costruire un qubit con circuiti superconduttori, cominceremo a studiare un circuito elettrico fondamentale che è alla base sia del qubit stesso sia del suo sistema di manipolazione.\nCircuito LC # Questo semplice circuito LC è costituito da un parallelo di un induttore e di un condensatore. Agisce come un risonatore che immagazzina energia oscillando alla sua frequenza di risonanza. L\u0026rsquo;energia è divisa tra la carica all\u0026rsquo;interno del condensatore e il campo magnetico formato all\u0026rsquo;interno dell\u0026rsquo;induttore dalla corrente passante e può essere descritta dalla seguente Hamiltoniana:\n$$ \\begin{aligned} H = \\frac{Q^2}{2C} + \\frac{\\Phi^2}{2L} \\end{aligned} $$\nA causa della forma quadratica dell\u0026rsquo;energia, il potenziale all\u0026rsquo;interno di tale circuito è parabolico.\nApplicando quindi la quantizzazione del circuito si ottiene l\u0026rsquo;Hamiltoniana dell\u0026rsquo;oscillatore armonico quantistico con energie accessibili discrete derivanti dal profilo del potenziale. L\u0026rsquo;Hamiltoniana dell\u0026rsquo;oscillatore armonico quantistico può essere riscritta attraverso il formalismo degli operatori di creazione e annichilazione come:\n$\\hat{H} = \\hbar w_r ( \\hat{a} ^ \\dagger \\hat{a} + \\frac{1}{2})$\nSi noti che l\u0026rsquo;armonicità fa sì che i salti di energia siano tutti pari a $\\hbar w_r$ con $w_r = \\frac{1}{\\sqrt{L C}}$ uguale alla frequenza di risonanza del circuito.\nLinea di trasmissione # La linea di trasmissione è un modello di circuito che trasporta energia elettromagnetica senza perdite significative. Può essere schematizzata come un modello a elementi concetrati composto da un array di circuiti LC accoppiati. Cortocircuitando entrambe le estremità della linea di trasmissione verso massa si ottiene un vero e proprio risonatore in cui i vettori d\u0026rsquo;onda ammessi sono discretizzati come:\n$k = {2 \\pi n}/L$\ncon L uguale alla lunghezza del risonatore e $n = 1, 2, 3\u0026hellip;$\nL\u0026rsquo;Hamiltoniana può essere nuovamente scritta in termini di operatori di creazione e annichilazione che creano e distruggono un\u0026rsquo;onda con vettore d\u0026rsquo;onda $k$:\n$$ \\begin{aligned} \\hat{H} = \\sum_{n=0} \\hbar w_n [\\hat{a}(w_n)^ \\dagger \\hat{a}(w_n)] \\end{aligned} $$\ncon $w_n = (n + 1)w_r$ tali le frequenze dei modi ammessi. Il concetto di linea di trasmissione come risonatore tornerà utile nelle parti successive, quando verrà utilizzato per leggere lo stato del qubit mediante accoppiamento capacitivo.\nQubit a superconduttore # Utilizzando i concetti illustrati sopra, passiamo ora alla costruzione di un qubit a superconduttore. A tal fine dovremo fondere concetti elettronici classici come il circuito LC con un po\u0026rsquo; di magia superconduttiva.\nAtomi artificiali # Quando si utilizza una tecnologia per realizzare un qubit, è necessario tenere presente il comportamento che vogliamo che questo abbia. Il concetto di atomi artificiali è il modello che descrive con precisione le caratteristiche desiderate del qubit. In pratica vogliamo che il nostro sistema fisico si comporti come un atomo naturale, con i suoi salti di energia disomogenei e discreti che possono essere controllati inviando accuratamente dei segnali e allo stesso modo essere facilmente letti. Vorremmo quindi dche il sistema abbia livelli energetici discreti e transizioni anarmoniche tra di essi in modo che ciascun salto energetico possa essere controllato indipendentemente tramite segnali con uguale energia.\nNel caso dei qubit come atomi artificiali, vorremmo che i portatori di informazione, nel nostro caso le coppie di Cooper, mantenessero l\u0026rsquo;informazione per lunghi tempi, che in questo quadro equivale a dire tempi di coerenza. È inoltre fondamentale evitare fluttuazioni termiche con energia superiore alla transizione in esame, in modo da evitare eccitazioni indesiderate dei portatori. Infine, il rischio maggiore di decoerenza dovuto alle influenze ambientali deve essere adeguatamente contenuto.\nQubiti di carica # Prendiamo ora il circuito LC descritto sopra e sostituiamo l\u0026rsquo;induttore lineare con una giunzione Josephson. Quello che otterremo è la prima forma di qubit a superconduttore che possiamo considerare, chiamato anche qubit di carica.\nIl condensatore orizzontale che collega il generatore con la giunzione simboleggia l\u0026rsquo;accoppiamento capacitivo del qubit a una sorgente di tensione arbitraria. Il qubit di carica è costituito semplicemente da una giunzione Josephson in parallelo ad un condensatore. La differenza fondamentale rispetto a un normale circuito LC è il comportamento non lineare della giunzione. La caratteristica sinusoidale della sua corrente dà origine a un profilo anarmonico del potenziale:\n$$ \\begin{aligned} \\hat{H} = 4E_c \\hat{n}^2 - E_j cos(\\phi) \\end{aligned} $$\ndove $\\hat{n}$ è l\u0026rsquo;operatore numero che è direttamente collegato agli operatori di creazione e annichilazione e rappresenta il numero di coppie di Cooper all\u0026rsquo;interno del circuito, $E_c$ è l\u0026rsquo;energia di carica con una proporzionalità inversa rispetto alla capacità del condensatore e $E_j$ è l\u0026rsquo;energia Josephson mentre $\\phi$ è la differenza di fase della funzione d\u0026rsquo;onda macroscopica attraverso la giunzione.\nIl comportamento quadratico dell\u0026rsquo;energia risiede ora interamente nell\u0026rsquo;operatore numero, mentre il potenziale non lineare della giunzione dà luogo a salti anarmonici all\u0026rsquo;interno del suo profilo.\nGrazie all\u0026rsquo;anarmonicità del potenziale, le transizioni energetiche discrete accessibili in chiave quantistica sono ora disomogenee e consentono di controllare due stati in modo indipendente.\nRegime transmonico # Storicamente, le prime implementazioni del qubit a superconduttore erano qubit di carica, in cui l\u0026rsquo;informazione era codificata nella quantità di coppie di Cooper all\u0026rsquo;interno del circuito. La principale fonte di rumore che degrada tali sistemi è il rumore di carica, dovuto alle cariche in prossimità del circuito spinte dal generatore di tensione che il qubit percepisce, modellabile come una fluttuazione parametrica ($n_g$) del numero di portatori nell\u0026rsquo;Hamiltoniana: $$ \\begin{aligned} \\hat{H} = 4E_c (\\hat{n}^2-n_g^2) - E_j cos(\\phi) \\end{aligned} $$ la fluttuazione potrebbe anche cambiare nel tempo. La principale conseguenza del rumore di carica è la costante variazione delle frequenze di transizione del sistema rendendo quasi impossibile il controllo del qubit.\nPer attenuare l\u0026rsquo;influenza di questo tipo di rumore, il contributo dell\u0026rsquo;energia Josephson nell\u0026rsquo;Hamiltoniana deve superare quello dell\u0026rsquo;energia di carica. L\u0026rsquo;implementazione di un dispositivo di interferenza quantistica a superconduttore (SQUID) per controllare $E_j$ o l\u0026rsquo;aumentare dell\u0026rsquo;area del condensatore per ridurre $E_c$ sono valide alternative per manipolare il rapporto $E_j/E_c$.\nL\u0026rsquo;immagine sovrastante mostra il rapporto tra i livelli energetici con l\u0026rsquo;energia dello stato fondamentale in funzione della carica di rumore. È evidente che con bassi valori di $E_j/E_c$ piccole variazioni di $n_g$ portano a cambiamenti deleteri nelle transizioni energetiche. Quando $E_j/E_c$ è nell\u0026rsquo;intervallo $20-80$ si dice che il qubit è in regime transmonico e la sensibilità alle fluttuazioni di carica è quasi completamente soppressa. Si noti anche che l\u0026rsquo;anarmonicità nelle transizioni si riduce con valori più alti di $E_j/E_c$, ma decade più lentamente dell\u0026rsquo;influenza della fluttuazione di carica, cosicché il qubit è ancora considerabile come un oscillatore quantistico anarmonico.\nEssendo in regime transmonico, trascurando quindi il termine di carica di rumore nell\u0026rsquo;Hamiltoniana ed esprimendo l\u0026rsquo;energia con gli operatori di creazione e annichilazione, si trova questa forma finale:\n$hat{H} = \\hbar w_q \\hat{b} ^ \\dagger \\hat{b} - E_c/\\hat{b}^ \\dagger \\hat{b} ^\\dagger \\hat{b}\\hat{b}$\ndove $\\hbar w_q = \\sqrt{8 E_c E_j} - E_c$ è la frequenza corretta del trasmone e si riferisce alla prima transizione di energia nello spettro.\nImplementazione tecnologica # Il modello Jaynes - Cummings # Ora che abbiamo costruito il nostro atomo, ci sono alcuni problemi importanti da risolvere: come possiamo controllare lo stato quantistico senza perturbarlo? Come misurarlo invece? Prima di parlarne, dobbiamo fare un passo indietro, utilizzando un parallelismo per capire meglio il nostro sistema fisico.\nSappiamo che, se trasmettiamo un raggio laser verso un atomo alla giusta frequenza, possiamo eccitare il suo stato, promuovendo l\u0026rsquo;elettrone orbitante a un livello energetico superiore.\nQuesto modello è descritto dall\u0026rsquo; hamiltoniana di Jaynes - Cummings:\n$$ \\begin{aligned} \\hat H_{JC} = \\omega_r \\hat a^\\dagger \\hat a + \\frac{\\omega_{01}}{2} \\hat\\sigma_z + g (\\hat a^\\dagger \\hat\\sigma_- + \\hat a \\hat\\sigma_+) \\end{aligned} $$\nL\u0026rsquo;interazione luce-materia è ben descritta nel terzo elemento:\nla diseccitazione dell\u0026rsquo;atomo porta alla creazione di un fotone “sacrificare” un fotone significa eccitare l\u0026rsquo;atomo Questo controllo a livello atomico può essere ben eseguito all\u0026rsquo;interno di un risonatore ottico. Un risonatore è una struttura in grado di selezionare determinate frequenze d\u0026rsquo;onda per risuonare in un sistema. Prendiamo ad esempio una chitarra: le sue corde emettono determinate note perché ne selezioniamo una certa lunghezza, premendo le corde sulla sua superficie.\nUn esempio noto in fisica è la cavità di Fabry-Perot, utilizzata per la costruzione dei laser: se mettiamo due specchi uno di fronte all\u0026rsquo;altro a una certa distanza, solo poche frequenze di onde elettromagnetiche oscilleranno tra loro. Mettere un atomo all\u0026rsquo;interno della cavità di Febry - Perot ci permette di controllarne lo stato energetico.\nFacciamo lo stesso per il nostro qubit transmon: se lo poniamo all\u0026rsquo;interno di un risonatore fatto di linee di trasmissione superconduttrici, potremo controllarlo e misurarlo.\nPer dimostrare ciò, esaminiamo il circuito equivalente di questo sistema, per ricavarne l\u0026rsquo;hamiltoniana. La tecnica di studiare i sistemi quantistici analizzando il loro circuito equivalente è chiamata elettrodinamica quantistica dei circuiti (QED).\nLa derivazione di questo circuito è semplice:\nil risonatore è rappresentato da un oscillatore armonico (circuito LC) il qubit è rappresentato da un oscillatore anarmonico (circuito JJ + C) L\u0026rsquo;accoppiamento tra i due è rappresentato da una capacità ($C_g$). L\u0026rsquo;hamiltoniana corrispondente a questo circuito è: $$ \\begin{aligned} \\hat H = (\\frac{\\hat Q^2_r}{2C_r} +\\frac{\\hat \\Phi ^2_r}{ 2 L_r}) + (4 E_c \\hat n^2 - E_j cos \\hat \\phi) \\end{aligned} $$\nche, con alcune approssimazioni, è equivalente al modello di Jayes - Cummings.\nQuindi, possiamo controllare l\u0026rsquo;informazione immagazzinata in un qubit con onde elettromagnetiche così come possiamo controllare lo stato energetico di un atomo con un laser!\nIl regime dispersivo # Ora che il nostro modello è pronto per essere utilizzato, c\u0026rsquo;è un problema importante da risolvere: come possiamo modificare lo stato del qubit senza perturbarlo?\nSappiamo dai concetti di base della fisica quantistica che entrare in contatto con un sistema quantistico porta al suo collasso: pertanto dobbiamo trovare un modo per modificare l\u0026rsquo;informazione quantistica e creare un computer utile.\nLa soluzione si ottiene nel regime dispersivo: l\u0026rsquo;idea principale è quella di utilizzare due frequenze diverse, una per il controllo ($\\omega_{01}$) e una per la lettura ($\\omega_r$), in modo da effettuare due operazioni distinte sul qubit.\nSe scegliamo queste due frequenze in modo tale che: $$ \\begin{aligned} \\Delta = | \\omega_{q}-\\omega_r| \u0026raquo; g \\end{aligned} $$\nl\u0026rsquo;hamiltoniana di Jaynes - Cummings può essere approssimata a:\n$$ \\begin{aligned} \\hat H_{disp} = (\\omega_r + \\chi \\hat \\sigma z) \\hat a^\\dagger \\hat a + \\frac{\\omega{q}}{2}\\hat \\sigma_z \\end{aligned} $$ con $\\chi \\approx \\frac{g^2}{\\Delta} $.\nCiò ha due conseguenze dirette:\nse l\u0026rsquo;autovalore di $\\sigma_z$ è +1 (il qubit è in uno stato eccitato), la frequenza di risonanza del risonatore diventerà $\\omega_r + \\chi$\nSe l\u0026rsquo;autovalore di $\\sigma_z$ è -1 (il qubit è nel ground state), la frequenza di risonanza del risonatore diventerà $\\omega_r - \\chi$.\nCiò significa che lo stato del qubit influenza il sistema che lo circonda.\nCome si può notare da questa immagine, $\\omega_q$ e $\\omega_r$ sono molto distanti l\u0026rsquo;uno dall\u0026rsquo;altro.\nÈ ora di usare questo sistema!\nmisura: sondare il risonatore alla frequenza di $\\omega_r$; a seconda dello stato del qubit, la frequenza di trasmissione sarà a $\\omega_r + \\chi$ o $\\omega_r - \\chi$. controllo: sondare il risonatore a $\\omega_q$ con la forma d\u0026rsquo;onda necessaria per ruotare lo stato del qubit Controllo del qubit # Ma cosa intendiamo esattamente con “rotazione dello stato del qubit”? Come è possibile farlo con frequenze di risonanza?\nPrima di parlarne, dobbiamo fare un breve riepilogo su un argomento importante nell\u0026rsquo;analisi dei segnali: la modulazione I/Q.\nUn segnale (una forma d\u0026rsquo;onda generica, come una sinusoide) può essere scomposto in due componenti additive:\nun segnale in fase (I), che avrà fase zero un segnale in quadratura (Q), con fase pari a $\\frac{\\pi}{2}$. ![alt text](images/\u0026lt;I_Q time components.png\u0026gt;)\nUn segnale a frequenza fissa può anche essere rappresentato come un punto in un piano complesso, i cui assi indicano le componenti I e Q che lo costituiscono:\n![alt text](images/\u0026lt;I_Q complex components.png\u0026gt;)\nUtilizzando nuovamente la tecnica QED, si ricava l\u0026rsquo;hamiltoniana della tensione di pilotaggio e del sistema di qubit controllati:\n$$ \\begin{aligned} \\hat H_d = \\Omega V_0 s(t) (I \\sigma_x + Q \\sigma_y) \\end{aligned} $$\ndove:\n$\\Omega = \\frac{C_d}{C_\\Sigma} Q_0$ (costante relativa al circuito equivalente) $V_0$ è l\u0026rsquo;ampiezza della tensione generata $s(t)$ è la forma d\u0026rsquo;onda del segnale L\u0026rsquo;idea principale è quella di modulare le componenti I e Q del segnale di pilotaggio per selezionare una rotazione lungo l\u0026rsquo;asse x o y del qubit.\nQuindi, si hanno due casi:\nse Q = 0, si ottiene la rotazione intorno all\u0026rsquo;asse x se I = 0, si ottiene la rotazione intorno all\u0026rsquo;asse y Il caso della rotazione attorno all\u0026rsquo;asse z è diverso; infatti, il gate z è detto \u0026ldquo;virtuale\u0026rdquo;, poiché non possiamo eseguire direttamente una rotazione attorno all\u0026rsquo;asse z, ma solo regolare la fase del segnale per trasformare le sue componenti I e Q:\n$I\u0026rsquo; = I \\cos \\phi - Q \\sin \\phi $\n$Q\u0026rsquo; = I \\sin \\phi - Q \\cos \\phi $\nIn tutti e tre i casi, l\u0026rsquo;angolo di rotazione è legato alla durata del segnale di pilotaggio.\nThat\u0026rsquo;s all, folks! # Con questo articolo vi abbiamo spiegato:\ncos\u0026rsquo;è la superconduttività; cos\u0026rsquo;è un qubit transmon; come manipolare il qubit in un computer quantistico superconduttivo. Se questo articolo vi è piaciuto, condividetelo con i vostri amici quantistici! O anche con il vostro cane, il vostro gatto, il vostro cavallo\u0026hellip;\n","date":"28 aprile 2025","externalUrl":null,"permalink":"/articles/hardware_superconducting_qubits_08_05_2025_gvpgje/superconducting-qubits/","section":"Articoli","summary":"Introduzione sulla superconduttività, la costruzione di un qubit transmon e il controllo dell\u0026rsquo;informazione in un computer quantistico superconduttivo","title":"Qubit superconduttivi","type":"articles"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/tags/superconducting/","section":"Tags","summary":"","title":"Superconducting","type":"tags"},{"content":" 🔍 Hackathon interno Autunno 2023 Il team ha affrontato una sfida interna incentrata sullo sviluppo dell\u0026#39;algoritmo di Grover. I team, composti in modo eterogeneo, hanno lavorato in autonomia e in competizione tra loro, ricreando lo spirito autentico di un hackathon.\nGoogle DevFestAlps 2023 🎤 DevFestAlps 2023 2023 Sul palco del Google DevFestAlps presso il Toolbox Coworking a Torino, abbiamo presentato il nostro lavoro sull\u0026#39;algoritmo di Grover e gli oracoli quantistici.\n✨ Esplorando le Opportunità Quantistiche 2023 Il nostro primo grande evento di divulgazione al Politecnico di Torino in collaborazione con BeQuantum. Un grande successo con oltre 200 partecipanti in sala.\n🎓 Salone dell\u0026#39;Orientamento 2024 2024 Durante l\u0026#39;annuale Salone dell\u0026#39;Orientamento del Politecnico, ci siamo presentati a futuri studenti curiosi e interessati al mondo quantistico.\n🌍 ETH Quantum Hackathon 2024 2024 Il nostro primo hackathon internazionale all\u0026#39;ETH di Zurigo. Abbiamo lavorato intensamente per 24 ore su diverse challenge proposte da startup e aziende.\n🎤 DevFestAlps 2024 2024 Seconda partecipazione al Google DevFestAlps con un nuovo talk, condividendo la nostra passione per il quantum computing.\n🧠 Hackathon interno Autunno 2025 Secondo hackathon interno focalizzato su Quantum Optimisation e Quantum Machine Learning, con progetti originali ed esplorazione di nuovi orizzonti applicativi.\n💡 Pushquantum Hackathon 2024 Partecipazione all\u0026#39;hackathon internazionale presso il TUM Entrepreneurship Research Institute di Monaco di Baviera.\n🔢 Pi Greco Day 2025 Celebrazione del Pi Greco Day con prospettiva quantistica, esplorando il ruolo di π nella fisica teorica e nella meccanica quantistica.\n🚀 Salone dell\u0026#39;Orientamento 2025 Seconda partecipazione al Salone dell\u0026#39;Orientamento, incontrando nuovi studenti interessati alla fisica quantistica.\n","externalUrl":null,"permalink":"/activities/","section":"Attività","summary":"🔍 Hackathon interno Autunno 2023 Il team ha affrontato una sfida interna incentrata sullo sviluppo dell\u0026#39;algoritmo di Grover.","title":"Attività","type":"page"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categorie","summary":"","title":"Categorie","type":"categories"},{"content":"QubiTo nasce nel 2023 sulla scia dell\u0026rsquo;entusiasmo di studenti e professori del Politecnico di Torino verso la fisica quantistica e le sue contemporanee, promettenti prospettive tecnologiche. Insieme, uniti dalla passione per tale dinamismo, ricerchiamo e divulghiamo gli aspetti di questo affascinante mondo nelle sue innumerevoli declinazioni e sfruttiamo le nostre conoscenze e competenze partecipando in squadra ad hackaton internazionali. Con l\u0026rsquo;inaugurazione del primo quantum computer del Politecnico Spark IQM inizieremo infine ad applicare il nostro bagaglio di conoscenze teoriche nella realizzazione di progetti pratici!\nIl nostro team è attualmente composto da cinque divisioni che si occupano di approfondimenti interni al team stesso, relativi ad aree tecnologiche definite, per la maggior parte orientate alla computazione quantistica:\nHardware Si occupa del funzionamento pratico del computer quantistico, indagando la varietà di sistemi fisici utilizzati per codificare i bit quantistici \u0026ndash; i qubit \u0026ndash; e i sistemi elettronici impiegati per controllarli. Particolare attenzione è dedicata alla tecnologia superconduttiva, alla base del nuovo computer quantistico del Politecnico Spark IQM\nDecoerenza I sistemi fisici che manifestano proprietà quantistiche sono soggetti ad un naturale rilassamento che ne deteriora le proprietà stesse all\u0026rsquo;avanzare del tempo. Il fenomeno prende il nome di \u0026ldquo;decoerenza\u0026rdquo; e la sua caratterizzazione è di fondamentale importanza per garantire il corretto funzionamento di ogni computer quantistico. La divisione del team dedita allo studion della decoerenza effettua ricerche sui meccanismi disici che concorrono al fenomeno e come limitarlo efficacemente ai fini della computazione quantistica.\nCorrezione errori Laddove la parziale decoerenza del sistema fisico o l\u0026rsquo;interferenza dovuta al rumore dell\u0026rsquo;elettronica di controllo corrompano lo stato del qubit, l\u0026rsquo;implementazione di algoritmi per la correzione degli errori permette di recuperarne il valore originale. L\u0026rsquo;ottimizzazione di tali algoritmi è un aspetto di cruciale importanza, soprattutto nell\u0026rsquo;ottica di funzionamento di computer ancora troppo poco potenti. La divisione che si dedica alla correzione degli errori studia questi algoritmi nelle loro significative differenze rispetto agli analoghi ampiamente utilizzati per i computer classici.\nProgrammazione Le operazioni basilari che vengono eseguite dai qubit prendono il nome di \u0026ldquo;gates\u0026rdquo; e la loro opportuna combinazione rende idealmente possibile eseguire qualunque operazione che sia già alla portata di un computer classico. La vera potenza dei qubit risiede nel fatto che molti dei gates non hanno un corrispettivo classico, permettendo di effettuare computazioni complesse in maniera esponenzialmente più veloce nei casi più fortunati. La divisione di programmazione studia il modo di combinare i gates per ricavare algoritmi quantistici che dimstrino una maggiore rapidità di esecuzione rispetto alla controparte classica.\nComunicazioni La divisione che si occupa di comunicazione si allontana dall\u0026rsquo;implementazione del computer quantistico per concentrarsi sull\u0026rsquo;infrastruttura necessaria al trasferimento di informazione quantistica, ossia messaggi codificati in forma di qubit. Oltre all\u0026rsquo;implementazione pratica di un network quantistico e allo studio dell\u0026rsquo;informazione quantistica, particolare importanza è data all\u0026rsquo;approfondimento della crittografia quantistica, tecnologia promettente nella messa in sicurezza di comunicazioni confidenziali.\nUna sesta divisione si occupa della divulgazione esterna al team tramite i canali social di QubiTo, la stesura di articoli sul sito e la partecipazione ad eventi a contatto con il pubblico, approfondendo anche argomenti e applicazioni della fisica quantistica più distanti dalla computazione quantistica. Una sottodivisione di programmatori si occupa inoltre della gestione e del miglioramento del sito.\n","externalUrl":null,"permalink":"/team/","section":"","summary":"QubiTo nasce nel 2023 sulla scia dell\u0026rsquo;entusiasmo di studenti e professori del Politecnico di Torino verso la fisica quantistica e le sue contemporanee, promettenti prospettive tecnologiche.","title":"Chi Siamo","type":"page"},{"content":" Mettiti in Contatto con Noi! Se desideri supportarci nella nostra missione o unirti a noi nel nostro percorso, non esitare a contattarci. Siamo sempre grati per l\u0026rsquo;aiuto e il sostegno della nostra comunità.\nInformazioni di Contatto\nEmail: qubito@polito.it\nSocial Media:\nInstagram Linkedin I nostri partner Partner principale Politecnico di Torino\nSeguici Rimani aggiornato sui nostri ultimi progetti ed eventi seguendoci sui social media!\nIl tuo aiuto è molto importante per noi! Che tu abbia domande, suggerimenti o semplicemente voglia salutarci, il tuo contributo è prezioso per noi. Grazie per essere con noi in questa avventura!\n","externalUrl":null,"permalink":"/contacts/","section":"","summary":"Mettiti in Contatto con Noi!","title":"Contatti","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/snippets/","section":"Snippets","summary":"","title":"Snippets","type":"snippets"}]