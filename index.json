[{"content":" Questo è il primo articolo di una serie su Qiskit e partirà dalle basi. Nonostante ci siano molti video e articoli simili online, l\u0026rsquo;obiettivo di questa lezione è fornire ai nuovi studenti un primo approccio pratico all\u0026rsquo;argomento con - si spera - un buon equilibrio tra dettagli e facilità per un principiante. Dopo questa lezione dovresti essere in grado di iniziare a creare e simulare circuiti in Qiskit.\nConcetti preliminari # Nel caso tu non sia familiare con i circuiti quantistici e le porte, ti consiglio di dare un\u0026rsquo;occhiata a IBM Quantum Composer, Quirk quantum circuit simulator e Bloch sphere simulator. Questi strumenti sono un ottimo modo per familiarizzare con il mondo quantistico utilizzando un\u0026rsquo;interfaccia grafica.\nPrimi passi con Qiskit # Prima di scrivere codice da soli, possiamo provare a eseguire il codice presente nel composer per confermare che ciò che stavamo vedendo fosse effettivamente codice Qiskit. Guarda nel pannello di destra del composer e dovresti vedere del codice Python simile all\u0026rsquo;immagine seguente (potresti dover selezionare \u0026ldquo;Qiskit\u0026rdquo; dal menu a discesa se \u0026ldquo;OpenQASM 2.0\u0026rdquo; è già selezionato).\nSe non vuoi aprire il composer solamente per questo step, puoi copiare il codice qui sotto\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from numpy import pi qreg_q = QuantumRegister(2, \u0026#39;q\u0026#39;) creg_c = ClassicalRegister(2, \u0026#39;c\u0026#39;) circuit = QuantumCircuit(qreg_q, creg_c) circuit.h(qreg_q[0]) circuit.cx(qreg_q[0], qreg_q[1]) circuit.measure(qreg_q[0], creg_c[0]) circuit.measure(qreg_q[1], creg_c[1]) Se tutto ha funzionato correttamente, Jupyter dovrebbe dare il seguente output:\n\u0026lt;qiskit.circuit.instructionset.InstructionSet at 0x7f84d02584c0\u0026gt; Questo è un primo passo, ma ci piacerebbe vedere qualcosa di un po\u0026rsquo; più rappresentativo, come il disegno del circuito!\nPrima di vedere come disegnare i circuiti, analizziamo brevemente il codice sopra:\nLe prime due righe con from ... import ... servono per importare librerie Python che contengono le funzioni e le classi necessarie in seguito. Non preoccuparti troppo dei dettagli per ora, ricorda solo di includere ciò che è necessario prima di eseguire il codice.\nA questo punto possiamo iniziare con la creazione del circuito stesso; come primo passo creiamo un registro quantistico e uno classico. I registri sono collezioni di bit o qubit; se non hai esperienza con i computer classici, puoi vederli come un modo per raggruppare (q)bit che hanno un significato simile. Per fare un esempio, se stai cercando di creare un circuito che somma due numeri a 3 cifre A e B, potresti creare un registro regA con tre bit per memorizzare le cifre di A e fare lo stesso per B; in questo modo è più facile ricordare il significato di ciascun bit. Sebbene i registri siano utili quando si creano circuiti complessi, possono creare confusione con circuiti molto semplici come quelli in questo articolo; per questo motivo non li utilizzerò molto in seguito.\nLa cosa importante da ricordare è che un QuantumRegister è un array di qubit, quindi scrivere qreg_q[0] significa \u0026ldquo;prendere il primo qubit nel registro quantistico qreg_q\u0026rdquo;.\nOra possiamo procedere creando un circuito quantistico chiamato circuit che contiene 2 qubit (quelli in qreg_q) e 2 bit (quelli in creg_c).\nSe vogliamo iniziare ad aggiungere porte e operazioni al circuito, possiamo utilizzare la sintassi mostrata nelle righe seguenti. In questo esempio applichiamo una porta Hadamard (h) al primo qubit e poi una porta CNOT (cx) che è controllata dal primo qubit e ha come target il secondo qubit.\nInfine, misuriamo (measure) i due qubit salvando i risultati nei rispettivi bit classici.\nDisegnare un circuito # Ora che abbiamo un\u0026rsquo;idea di cosa fa il codice sopra, vogliamo vedere come appare nella realtà. È molto semplice: basta aggiungere la seguente riga al codice e rieseguirlo.\ncircuit.draw(output=\u0026#34;mpl\u0026#34;) # Possibili formati di output: None, mpl, latex Dovresti vedere un\u0026rsquo;immagine come la seguente, che corrisponde esattamente a quello che vedevamo nel composer!\nNota che potresti ricevere un errore se non hai alcune librerie richieste. Se ciò accade, prova a installare le librerie specificate nell\u0026rsquo;output oppure prova a rimuovere output=\u0026quot;mpl\u0026quot;; il risultato non sarà così elegante, ma dovrebbe funzionare senza problemi. Se hai ulteriori dubbi, puoi fare riferimento alla documentazione.\nCome trattare circuiti e gate più complessi # Con quanto abbiamo visto prima, dovresti essere in grado di creare circuiti di base, ma presto diventerà difficile creare algoritmi avanzati senza introdurre un paio di concetti in più. Come esempio, ci piacerebbe risolvere un problema semplice:\nCome possiamo creare una porta OR in un circuito quantistico?\nQuesta domanda potrebbe sembrare sciocca all\u0026rsquo;inizio: perché dovremmo preoccuparci di creare una porta classica in un circuito quantistico? Per il momento non è troppo importante e può essere vista semplicemente come un esercizio, ma se vuoi approfondire puoi studiare gli oracoli per l\u0026rsquo;algoritmo di Grover; per implementarli, le porte classiche sono estremamente utili!\nUn\u0026rsquo;altra domanda che potrebbe sorgere è: perché vogliamo creare la porta OR e non la AND? Semplicemente perché abbiamo già la versione quantistica della porta AND! jsi chiama porta Toffoli o controlled-controlled-not (ccx in Qiskit).\nEcco com\u0026rsquo;è fatta la porta Toffoli con la sua tabella della verità:\nPrima di tutto, notiamo che questa porta opera su 3 qubit e non su 2 come ci aspetteremmo; il motivo non è immediato. Per completare l\u0026rsquo;esercizio ti serve solo sapere che la porta Toffoli si comporta esattamente come una porta AND quando in input abbiamo $ C = |0\\rangle $; il risultato dell\u0026rsquo;AND sarà in $ C $ dopo l\u0026rsquo;applicazione della porta.\nPuoi verificare questa affermazione osservando che, se ignori le righe in cui $ C = |1\\rangle $, la tabella della verità della Toffoli diventa identica a quella dell\u0026rsquo;AND.\nLa ragione per cui il \u0026ldquo;quantum AND\u0026rdquo; richiede 3 qubit è che tutte le porte quantistiche devono essere reversibili, il che significa che, dato qualsiasi output della porta, deve essere possibile identificare in modo univoco l\u0026rsquo;input che l\u0026rsquo;ha generato. Ad esempio, guarda la tabella della verità della porta AND: se mi dici che l\u0026rsquo;output dell\u0026rsquo;AND è $ 0 $, non sarei in grado di sapere se l\u0026rsquo;input era 00, 01 o 10.\nA B A and B A or B 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 Torniamo alla domanda originale di creare la porta OR; abbiamo visto che abbiamo già l\u0026rsquo;AND, ma cosa ce ne facciamo? Prima di \u0026ldquo;invocare\u0026rdquo; teoremi, facciamo un paio di semplici passaggi logici e vediamo dove arriviamo:\nProviamo a completare la seguente tabella della verità in cui gli input sono stati \u0026ldquo;invertiti\u0026rdquo; rispetto alla precedente:\nnot A not B (not A) and (not B) not( (not A) and (not B) ) 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 1 Questa sembra una serie di operazioni arbitrarie, ma, se guardiamo l\u0026rsquo;ultima colonna, possiamo facilmente vedere che coincide con la colonna \u0026ldquo;OR\u0026rdquo; della prima tabella, il che significa che abbiamo creato la funzione \u0026ldquo;OR\u0026rdquo; utilizzando solo AND e NOT! Potremmo anche farlo formalmente usando la legge di De Morgan.\nOra abbiamo tutti gli ingredienti per procedere e creare la nostra prima porta personalizzata! Ma prima facciamo un riepilogo dei passaggi:\nVogliamo creare la porta OR su Qiskit partendo dalla porta AND (Toffoli) e dalla porta NOT (X). In Qiskit abbiamo già queste porte nella forma delle porte ccx e x. Utilizzando la legge di De Morgan (o i semplici passaggi sopra), abbiamo dimostrato la seguente equivalenza:\nA | B = !(!A \u0026amp; !B) oppure, se preferisci una notazione diversa:\n$$ A \\lor B \\equiv \\lnot (\\lnot A \\land \\lnot B) $$\nVediamo ora come convertire questa formula in un circuito quantistico: prima di tutto, sottolineiamo che i circuiti e le porte quantistiche, in Qiskit, possono essere utilizzati in modo intercambiabile. Ciò significa che possiamo creare un circuito quantistico come abbiamo fatto in precedenza e, successivamente, utilizzarlo come una singola porta. Vedremo più avanti come fare tutti i passaggi; per il momento concentriamoci sulla creazione di un circuito che implementi la porta OR, utilizzando la formula sopra.\nPer cominciare, abbiamo bisogno di un circuito con tre qubit: A e B, che sono gli input, e C, che conterrà l\u0026rsquo;output.\nqc = QuantumCircuit(3) Nota come, in questo caso, non ho utilizzato alcun registro ma ho semplicemente specificato il numero di qubit nei parametri di QuantumCircuit. Teniamo a mente che il primo qubit (cioè qc[0]) rappresenta A, il secondo rappresenta B e il terzo C.\nOra è solo una questione di vedere quale porta è applicata a quale qubit. Nella formula vediamo che abbiamo porte x (NOT) applicate sia a A che a B, quindi possiamo aggiungerle in Python come segue:\nqc.x(0) qc.x(1) Poi abbiamo una AND tra A e B; ricordati che la Toffoli (ccx) si comporta come una AND quando C (il target) è inizializzato a $ | 0 \\rangle $, quindi possiamo aggiungerlo come segue:\nqc.ccx(0, 1, 2) Infine, dobbiamo negare l\u0026rsquo;output (il primo NOT nella formula); poiché C è l\u0026rsquo;output, dobbiamo semplicemente aggiungere una porta x al terzo qubit:\nqc.x(2) Sembrerebbe di aver finito, vediamo come appare il circuito risultante a questo punto:\nQuesto circuito fornisce i risultati corretti ma ha un problema importante: cambia i valori dei suoi input! Guarda i primi 2 qubit, sono soggetti a una porta x e quindi il loro valore all\u0026rsquo;inizio è diverso da quello alla fine. Questo comportamento presenta dei problemi poiché ci impedisce di riutilizzare i valori originali di A e B.\nFortunatamente, risolvere il problema è molto semplice; dobbiamo solo applicare l\u0026rsquo;operazione inversa della porta x, che è\u0026hellip;\nla porta x stessa! (Negare una quantità due volte è come non fare nulla o, più formalmente, $ X \\cdot X = \\mathbb{I} $)\nQuindi, per risolvere il problema, basta aggiungere queste due righe:\nqc.x(0) qc.x(1) Il circuito finale per la OR è quindi:\nPer rendere il codice che abbiamo scritto più facile da usare in seguito (e per creare una vera porta), mettiamo tutto all\u0026rsquo;interno di una funzione che restituisce il circuito stesso:\ndef OR() -\u0026gt; QuantumCircuit: qc = QuantumCircuit(3) qc.barrier() qc.x(0) qc.x(1) qc.ccx(0, 1, 2) qc.x(0) qc.x(1) qc.x(2) qc.barrier() return qc In questo modo, quando avremo bisogno di utilizzare la porta OR in Qiskit, dovremo semplicemente chiamare questa funzione.\nNota che ho anche aggiunto due barrier all\u0026rsquo;inizio e alla fine della porta; le barriere non sono porte, ma sono semplicemente \u0026ldquo;linee verticali\u0026rdquo; che rendono più facile delimitare visivamente le cose quando si disegna il circuito (vedi il disegno sopra).\nNota poi l\u0026rsquo;annotazione -\u0026gt; QuantumCircuit nella prima riga, questo è il modo in cui è possibile specificare il tipo dell\u0026rsquo;oggetto restituito dalla funzione in Python; non è obbligatorio aggiungerlo (infatti, se non lo metti, non cambierà nulla nell\u0026rsquo;esecuzione del codice), ma consente al tuo IDE (ad esempio, VSCode) di offrirti suggerimenti utili mentre scrivi il codice.\nComporre circuiti # Se vogliamo utilizzare la nuova porta che abbiamo creato all\u0026rsquo;interno di un circuito più grande, non possiamo semplicemente scrivere circuit.OR perché questa non è una porta \u0026ldquo;nativa\u0026rdquo; di Qiskit. Quello che dobbiamo fare è \u0026ldquo;attaccarla\u0026rdquo; (cioè comporla) a un circuito esistente. Vediamo come:\nqc = QuantumCircuit(3) qc.x(0) qc.compose(OR(), [0,1,2], inplace=True) qc.draw() Nelle righe sopra, abbiamo creato un circuito quantistico con 3 qubit, applicato una porta x al primo (solo come esempio) e poi attaccato la nostra porta OR con la funzione compose. Questa funzione richiede i seguenti parametri: il primo è il circuito che vogliamo attaccare (l\u0026rsquo;OR in questo caso), poi una lista dell\u0026rsquo;ordine in cui attaccare i qubit (cioè come \u0026ldquo;collegare i cavi\u0026rdquo;). Nella maggior parte dei casi vogliamo collegare il primo qubit del circuito al primo input della porta, il secondo al secondo e così via\u0026hellip; L\u0026rsquo;ultimo parametro inplace dovrebbe sempre essere impostato su True, altrimenti il circuito originale non verrà modificato.\nDisegnando il circuito otteniamo:\nBonus tip # Quando si lavora con circuiti complessi, è facile \u0026ldquo;perdersi\u0026rdquo; tra decine e decine di gate. Per ridurre la complessità del disegno, possiamo utilizzare il metodo to_instruction, che disegnerà il nostro sotto-circuito come una semplice scatola:\nbox_OR = OR().to_instruction(label=\u0026#39;OR\u0026#39;) qc = QuantumCircuit(3) qc.x(0) qc.compose(box_OR, [0,1,2], inplace=True) qc.draw(\u0026#39;mpl\u0026#39;) Se invece vogliamo ispezionare un circuito dopo averlo convertito in istruzioni, possiamo decomporlo così\nbox_OR = OR().to_instruction(label=\u0026#39;OR\u0026#39;) qc = QuantumCircuit(3) qc.x(0) qc.compose(box_OR, [0,1,2], inplace=True) qc.decompose().draw(\u0026#39;mpl\u0026#39;) Nota anche come, decompose ci mostra che la porta x in realtà viene implementata come una U3.\nSimulare un circuito quantistico # Ora siamo abbastanza bravi a creare circuiti, ma finora non ne abbiamo eseguito neanche uno. Vediamo come fare usando uno dei tanti modi possibili per simulare circuiti in Qiskit. Il metodo riportato qui esegue una simulazione ideale, cioè senza alcuna fonte di rumore, decoerenza e così via. Se desideri approfondire ulteriormente, puoi controllare la documentazione:\nhttps://qiskit.github.io/qiskit-aer/tutorials/1_aersimulator.html https://docs.quantum.ibm.com/guides/simulate-with-qiskit-aer Prima di continuare, importa le librerie necessarie (in aggiunta a quelle importate all\u0026rsquo;inizio)\nfrom qiskit import transpile from qiskit_aer import AerSimulator from qiskit.visualization import plot_histogram, plot_state_city Quando vogliamo eseguire una simulazione, abbiamo anche bisogno di alcuni bit classici per \u0026ldquo;salvare\u0026rdquo; i risultati delle misurazioni, quindi aggiungiamoli al circuito che vogliamo simulare. Possiamo farlo in due modi: manualmente (specificando i bit classici quando creiamo il circuito e poi utilizzandoli quando chiamiamo measure_all), oppure lasciando che la funzione measure_all li aggiunga per noi. Qui riporto entrambe le soluzioni, ma, nella maggior parte dei casi, la seconda strada è più conveniente.\nqc = QuantumCircuit(3, 3) qc.compose(OR(), inplace=True) qc.measure_all(add_bits=False) qc.draw(\u0026#39;mpl\u0026#39;) qc = QuantumCircuit(3) qc.compose(OR(), inplace=True) qc.measure_all() qc.draw(\u0026#39;mpl\u0026#39;) Ora siamo pronti per eseguire la simulazione. Dato che questo è un argomento piuttosto complesso da trattare in dettaglio, la seguente è solo una \u0026ldquo;ricetta\u0026rdquo; di base che può essere utilizzata in casi semplici. Per simulazioni più avanzate o per comprendere i vari passaggi, fai riferimento ai link sopra.\nsim = AerSimulator() transpiled_qc = transpile(qc, sim) result = sim.run(transpiled_qc).result() counts = result.get_counts(transpiled_qc) plot_histogram(counts) Ciò che otteniamo è un istogramma simile al seguente:\nPoiché il circuito è semplicemente una porta OR con i due input impostati su 0, vediamo che tutti i qubit (i due input e l\u0026rsquo;output) valgono su 0, poiché (0 | 0 = 0).\nProva a sperimentare con il circuito (ad esempio, aggiungendo porte x agli input) per vedere se la simulazione corrisponde alle tue aspettative.\nEsercizio finale # Per testare ciò che hai imparato, prova a implementare da solo un half adder. Potrebbe sembrare complesso all\u0026rsquo;inizio, ma alla fine dovrai solo unire i pezzi che hai già con funzioni che già conosci.\nSe hai bisogno di aiuto, qui sotto puoi trovare il codice per la porta XOR di cui potresti avere bisogno:\n## XOR circuit def XOR() -\u0026gt; QuantumCircuit: qc = QuantumCircuit(3) qc.cx(0, 2) qc.cx(1, 2) return qc ","date":"16 maggio 2025","externalUrl":null,"permalink":"/articles/introduzione-a-qiskit/","section":"Articoli","summary":"Questa breve guida spiega le basi di Qiskit, quanto serve per creare gate personalizzati e come eseguire la simulazione ideale di un circuito","title":"Introduzione a Qiskit","type":"articles"},{"content":" Codici di ripetizione classici # Il rumore è una sfida fondamentale nei sistemi di elaborazione delle informazioni. Molti sistemi classici sono in grado di evitarlo completamente, mentre altri devono utilizzare codici di correzione degli errori per proteggersi dai suoi effetti. L\u0026rsquo;idea chiave è la ridondanza: codificando i messaggi con informazioni aggiuntive, gli errori possono essere rilevati e corretti anche se parte dei dati è corrotta. I codici di ripetizione sono esempi estremamente basilari di codici per la correzione degli errori.\nProcedure di codifica e decodifica # L\u0026rsquo;idea fondamentale è proteggere un bit dagli errori ripetendolo più volte. Si consideri il codice di ripetizione a 3 bit, in cui un singolo bit viene codificato come tre bit identici.\n$$ \\begin{aligned} 0 \u0026amp;\\mapsto 000 \\cr 1 \u0026amp;\\mapsto 111 \\end{aligned} $$ In assenza di errori, il bit originale può essere decodificato in modo banale. Tuttavia, anche se un solo bit viene invertito, il valore originale può comunque essere recuperato tramite votazione di maggioranza: il decodificatore restituisce il valore che appare più frequentemente. $$ abc \\mapsto majority(a,b,c) $$ Questo corregge in modo affidabile gli errori a singolo bit.\nNaturalmente, se 2 o 3 bit della codifica vengono invertiti, la decodifica non funzionerà correttamente e verrà recuperato il bit errato, ma se al massimo 1 dei 3 bit si inverte, la decodifica sarà corretta. Questo mostra un concetto centrale nella correzione degli errori: il compromesso tra ridondanza e robustezza.\nAnalisi degli errori nei canali binari simmetrici # Ad esempio, supponiamo di voler comunicare un singolo bit a un ipotetico ricevitore attraverso un canale classico rumoroso. L\u0026rsquo;effetto del rumore nel canale è quello di invertire un bit trasmesso con probabilità $p$, mentre con probabilità $1-p$ il bit viene trasmesso correttamente. Un canale di questo tipo è noto come canale binario simmetrico, in quanto inverte ogni bit inviato in modo indipendente.\nIn questo contesto, se scegliamo di non utilizzare alcun codice di correzione degli errori e semplicemente inviamo un bit qualsiasi attraverso il canale, il ricevitore riceverà il bit errato con probabilità $p$.\nD\u0026rsquo;altra parte, se prima utilizziamo il codice di ripetizione per codificare il bit e poi inviamo ciascuno dei tre bit risultanti attraverso il canale, ognuno di essi verrà invertito indipendentemente con probabilità $p$. Il ricevitore decodificherà correttamente solo se al massimo un bit viene invertito durante la comunicazione. Quindi la probabilità di un errore dopo la decodifica corrisponde alla probabilità che due o ciascuno dei tre bit si invertano durante la trasmissione. La probabilità totale di un errore è quindi $$ 3p^2(1-p)+p^3 = 3p^2-2p^3. $$\nQuesto può essere calcolato utilizzando la teoria della probabilità. Supponiamo di indicare con $$ p(X_1 \\cap X_2 \\cap X_3) $$ la probabilità che, quando riceviamo la stringa di bit a 3 cifre, otteniamo il risultato $X_i$ per l\u0026rsquo;$i$-esimo bit, il cui valore può essere $C_i$ per un rilevamento corretto e $W_i$ per uno errato.\nConsideriamo il caso in cui tutti e tre i bit siano errati, poiché i tre eventi sono indipendenti per ipotesi, la probabilità dell\u0026rsquo;intersezione degli eventi è il prodotto delle probabilità dei singoli eventi, $$ p(W_1 \\cap W_2 \\cap W_3) = p(W_1) p(W_2) p(W_3) = p^3. $$ Analizzando il caso in cui un solo bit viene ricevuto correttamente, vediamo che uno scenario possibile è il seguente: $$ p(C_1 \\cap W_2 \\cap W_3) = p(C_1) p(W_2) p(W_3) = (1-p)p^2. $$ Ma può verificarsi anche questo (con lo stesso calcolo): $$ p(W_1 \\cap C_2 \\cap W_3) = (1-p)p^2; $$ e questo: $$ p(W_1 \\cap W_2 \\cap C_3) = (1-p)p^2. $$ L\u0026rsquo;espressione finale per l\u0026rsquo;evento di ricezione di un solo bit corretto è $$ p\\big((C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big). $$\nPoiché i tre eventi composti considerati hanno un\u0026rsquo;intersezione vuota (un bit non può essere contemporaneamente corretto e sbagliato), la teoria ci dice che possiamo semplicemente sommare le singole probabilità, $$ \\begin{aligned} p\u0026amp; \\big((C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big) = \\cr \u0026amp;= p(C_1 \\cap W_2 \\cap W_3) + p(W_1 \\cap C_2 \\cap W_3) + p(W_1 \\cap W_2 \\cap C_3) = \\cr \u0026amp;=3(1-p)p^2. \\end{aligned} $$\nInfine, dobbiamo considerare l\u0026rsquo;evento composto: tutti i bit sono errati o un solo bit è corretto. Poiché questi hanno un\u0026rsquo;intersezione vuota, otteniamo $$ \\begin{aligned} p\u0026amp;\\Big( \\big( (C_1 \\cap W_2 \\cap W_3) \\cup (W_1 \\cap C_2 \\cap W_3) \\cup (W_1 \\cap W_2 \\cap C_3)\\big) \\cup (W_1 \\cap W_2 \\cap W_3) \\Big) = \\cr \u0026amp;= p^3 +3(1-p)p^2 =3p^2 -2p^3. \\end{aligned} $$ Errore Binario Simmetrico Come si può vedere nella figura sopra, quando la probabilità di errore $p$ è inferiore a $1/2$, il codice di ripetizione riduce efficacemente la possibilità che il destinatario riceva un bit errato. Al contrario, se $p$ supera $1/2$, il codice amplifica la probabilità di decodificare erroneamente.\nCodici di Ripetizione Quantistica per i Qubit # Il codice di ripetizione a 3 bit può essere utilizzato anche per la correzione degli errori nei qubit.\nCodifica degli Stati Quantistici # Per creare uno stato ripetuto a 3 qubit, possiamo utilizzare il circuito mostrato nella figura sotto. Con questo circuito possiamo codificare lo stato generico $\\alpha \\ket{0}+ \\beta \\ket{1}$ nello stato $\\alpha \\ket{000}+ \\beta \\ket{111}$, grazie all\u0026rsquo;azione delle porte NOT controllate (CNOT).\nSchema circuitale del codice a inversione di bit a 3 qubit Si noti che questa codifica è diversa dalla ripetizione dello stesso stato tre volte $\\ket{\\psi}\\otimes\\ket{\\psi}\\otimes\\ket{\\psi}$, cosa che sarebbe impossibile a causa del teorema di non clonazione.\nRilevamento e correzione degli errori di inversione di bit # Il primo tipo di errore che possiamo correggere sfruttando qubit di ripetizione è l\u0026rsquo;inversione di bit. Questo tipo di errore è rappresentato da una porta $X$. Se uno dei tre qubit, diciamo quello centrale, subisce questo tipo di errore, lo stato finale del sistema sarebbe $\\alpha \\ket{010}+ \\beta \\ket{101}$. Per rilevare questo errore potremmo semplicemente misurare lo stato, ma ciò distruggerebbe la sovrapposizione.\nCome possiamo capire quale dei tre qubit è stato invertito senza misurarne direttamente lo stato? Il modo corretto per farlo è aggiungere un nuovo elemento al nostro sistema. Questo dovrebbe essere un sistema inizialmente disaccoppiato dai nostri qubit, che entra in contatto con lo stato principale e ne viene influenzato in modo prevedibile, ma finisce comunque in uno stato disaccoppiato alla fine. Per disaccoppiamento si intende, in senso formale, quello che viene chiamato stato separabile. La proprietà principale di un sistema in uno stato separabile è che la misura di una delle sue porzioni non influenza il resto. Possiamo quindi sfruttare questa proprietà per dedurre, misurando il nuovo sistema, quale dei tre bit è stato invertito (supponendo di avere un solo inversione). Quindi applicando la porta $X$ inversa, cioè $X$ stessa in questo caso, al qubit che ha subito l\u0026rsquo;errore, possiamo ottenere nuovamente lo stato iniziale corretto.\nChiarito questo, e ricordando che misurando $n$ qubit possiamo ottenere $2^n$ diversi esiti, abbiamo bisogno solamente di due qubit aggiuntivi in grado di indicizzare i $2^2 = 4$ possibili risultati:\n00 se non ci sono errori;\n01 se il bit con errore è il terzo;\n10 se il bit con errore è il primo;\n11 se il bit con errore è il secondo.\nOra, vediamo come possiamo progettare un circuito che rispetti tutte le premesse. Consideriamo il nostro stato iniziale come $$ \\alpha \\ket{000} + \\beta \\ket{111}. $$ Ad esempio, se si verifica un errore sul primo qubit, si ottiene lo stato $$ \\alpha \\ket{100} + \\beta \\ket{011}. $$ Ora, possiamo provare a utilizzare alcune porte, ad esempio le C-NOT, per fare in modo che questa modifica influisca sui due qubit aggiuntivi. Possiamo farlo come mostrato nella figura seguente.\nCorrezione di un errore sul primo qubit Applicando quella porta CNOT, indicata come ${CX}_{i \\to j}$, dove l\u0026rsquo;$i$-esimo qubit è quello di controllo, otteniamo\n$$ \\begin{aligned} CX_{1\\to4} \\left( (\\alpha \\ket{100} + \\beta \\ket{011}) \\otimes \\ket{00} \\right) = \\cr = CX_{1\\to4} (\\alpha \\ket{100} \\otimes \\ket{00}) + CX_{1\\to4} (\\beta \\ket{011} \\otimes \\ket{00}) = \\cr = \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{00} \\end{aligned} $$\ndove abbiamo sfruttato la linearità nel secondo passaggio. Notiamo che il CNOT ha agito solo sulla prima parte del nostro stato di sovrapposizione. Tuttavia questo non è lo stato che vogliamo ottenere alla fine perché non è separabile, cioè non possiamo esprimerlo nella forma $$ \\begin{aligned} (\\alpha \\ket{100}+ \\beta \\ket{011} ) \\otimes \\ket{10} \\end{aligned} $$ Quest\u0026rsquo;ultimo è ciò che vorremmo ottenere, poiché vogliamo misurare gli ultimi due qubit e ottenere la stringa $10$, che indica un errore sul primo qubit, senza perturbare il nostro stato originale (i primi tre qubit).\nDobbiamo quindi modificare la seconda parte dello stato in uscita dal circuito precedente, quella legata al coefficiente $\\beta$, per ottenere $\\beta \\ket{011} \\otimes \\ket{10}$. Come possiamo farlo? Poiché il termine $\\alpha$ ha il primo qubit impostato a $1$, possiamo applicare un CNOT al secondo o al terzo qubit senza modificare quella parte dello stato. Quindi possiamo applicare il CNOT al secondo come mostrato nella seguente figura.\nCorrezione di un errore sul primo qubit (2) In questo modo, applicando la porta, otteniamo $$ \\begin{aligned} CX_{2\\to4} \\big( \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{00} \\big) = \\cr = CX_{2\\to4} (\\alpha \\ket{100} \\otimes \\ket{10}) + CX_{2\\to4} (\\beta \\ket{011} \\otimes \\ket{00}) = \\cr = \\alpha \\ket{100} \\otimes \\ket{10} + \\beta \\ket{011} \\otimes \\ket{10} = \\cr = \\big( \\alpha \\ket{100} + \\beta \\ket{011} \\big) \\otimes \\ket{10} \\end{aligned} $$ Questo è esattamente lo stato che cercavamo.\nErrore sul terzo qubit Se ora consideriamo un errore sul terzo qubit come nell\u0026rsquo;immagine sopra, che risulta nello stato $$ \\alpha \\ket{001} + \\beta \\ket{110}, $$ vediamo che il nostro circuito non funziona correttamente. Infatti, $$ \\begin{aligned} CX_{2\\to4} CX_{1\\to4} \\big( (\\alpha \\ket{001} + \\beta \\ket{110}) \\otimes \\ket{00} \\big) = \\cr = CX_{2\\to4} CX_{1\\to4} (\\alpha \\ket{001} \\otimes \\ket{00}) + CX_{2\\to4} CX_{1\\to4} (\\beta \\ket{110} \\otimes \\ket{00}) = \\cr = \\alpha \\ket{001} \\otimes \\ket{00} + \\beta \\ket{110} \\otimes \\ket{00} = \\cr = \\big( \\alpha \\ket{001} + \\beta \\ket{110} \\big) \\otimes \\ket{00}. \\end{aligned} $$\nSi noti che in questo caso, il CNOT che agisce sul primo termine della sovrapposizione (il termine $\\alpha$) non fa nulla, mentre il secondo termine risulta in due inversioni consecutive che si annullano a vicenda. Quindi, in questo caso, l\u0026rsquo;azione delle porte è equivalente all\u0026rsquo;identità, non si ottiene alcuna informazione sull\u0026rsquo;errore. Possiamo correggere questa situazione aggiungendo altre porte CNOT; come nella situazione precedente, dobbiamo aggiungerne due per avere uno stato separabile, come mostrato nella prossima figura.\nErrore corretto sul terzo qubit In questo modo, si ottiene il risultato $01$ in caso di errore sul terzo qubit. Si ricordi che i primi due CNOT si comportano come l\u0026rsquo;identità in questa situazione.\nSe torniamo al caso precedente, quello con l\u0026rsquo;errore sul primo qubit, vediamo che la situazione è simmetrica: le due porte che abbiamo aggiunto alla fine agiscono come l\u0026rsquo;identità, mentre le prime due agiscono come descritto in precedenza; tutto funziona ancora. Inoltre, questo circuito agisce sullo stato di assenza di errore come l\u0026rsquo;identità.\nErrore sul secondo qubit L\u0026rsquo;ultimo caso che dobbiamo analizzare è l\u0026rsquo;errore sul qubit centrale. Vogliamo, in questo caso, ottenere il risultato $11$. Vediamo cosa succede con il circuito attuale. Notiamo che il primo e l\u0026rsquo;ultimo CNOT agiscono solo sulla parte $\\beta$ della sovrapposizione. Quelli centrali, invece, agiscono solo sulla parte $\\alpha$. Se controlliamo, otteniamo lo stato separabile desiderato: $$ \\big( \\alpha\\ket{010}+\\beta\\ket{101} \\big) \\otimes \\ket{11}. $$ Il nostro circuito funziona!\nRiassumendo, possiamo facilmente calcolare i risultati della misurazione (sindromi) per tutti gli stati ottenuti da al massimo un bit-flip; li elenchiamo nella tabella seguente.\nStato Sindrome $\\alpha \\ket{000}+ \\beta \\ket{111}$ 00 $\\alpha \\ket{100}+ \\beta \\ket{011}$ 10 $\\alpha \\ket{010}+ \\beta \\ket{101}$ 11 $\\alpha \\ket{001}+ \\beta \\ket{110}$ 01 È importante sottolineare che gli errori di inversione di bit perfetti sono solo un modello semplice di un fenomeno molto più complesso; qui abbiamo ipotizzato una singola inversione rappresentata da un operatore unitario. Discuteremo degli errori non unitari alla fine dell\u0026rsquo;articolo.\nGestione degli errori di inversione di fase # Un altro tipo fondamentale di errore di cui dobbiamo preoccuparci sono gli errori di inversione di fase, modellati come porte $Z$. Applicando una porta $Z$ a uno qualsiasi dei tre qubit della codifica precedente, otteniamo $$ (\\mathbb{I}\\otimes Z \\otimes \\mathbb{I})(\\alpha \\ket{000}+ \\beta \\ket{111})=\\alpha \\ket{000}- \\beta \\ket{111}. $$ Si scopre che le inversioni di fase su uno qualsiasi dei tre qubit hanno lo stesso effetto sull\u0026rsquo;intero stato finale, portando a un\u0026rsquo;inversione di fase totale per un numero dispari di porte $Z$ applicate. Sfortunatamente il nostro precedente circuito di correzione degli errori non è in grado di rilevare errori di inversione di fase: l\u0026rsquo;uscita nei qubit ancilla sarà comunque $00$, senza rilevare alcun errore.\nCodice di ripetizione modificato per la mitigazione dell\u0026rsquo;inversione di fase # Per rilevare errori di inversione di fase, dobbiamo modificare lo stato codificato $\\alpha \\ket{000}+ \\beta \\ket{111}$ applicando tre porte Hadamard, raggiungendo quindi lo stato $\\alpha \\ket{+++}+ \\beta \\ket{\u0026mdash;}$. Questo viene fatto dal circuito nella figura sotto. Diagramma di correzione di fase a 3 qubit - prima parte Dopo questa codifica, un errore di inversione di fase trasformerà uno stato $\\ket{+}$ in uno $\\ket{-}$ e viceversa. Quindi, aggiungendo due qubit ancilla nello stato $\\ket{+}$, saremo in grado di riprodurre un circuito analogo a quello realizzato per le inversioni di bit, rappresentato nel diagramma seguente.\nDiagramma di correzione di fase completa a 3 qubit Come in precedenza, la sindrome misurata ci dirà se e dove si è verificato l\u0026rsquo;errore.\nLa correzione degli errori di inversione di fase ci impone quindi un cambio di base, effettuato tramite le porte di Hadamard.\nIl codice Shor a 9 qubit # Il codice di Shor a 9 qubit è ottenuto combinando il codice di ripetizione a 3 bit per gli errori di inversione di bit e di fase descritto in precedenza.\nStruttura del codice e codifica # I due codici di correzione degli errori appena visti saranno concatenati, dando origine a un circuito a 9 qubit. Questi due codici possono essere applicati in qualsiasi ordine, qui abbiamo scelto di applicare prima il codice di correzione degli errori di inversione di fase (codice esterno); i qubit risultanti saranno poi codificati utilizzando il codice di ripetizione per gli errori di inversione di bit (codice interno), esattamente come nella figura seguente.\nSchema del circuito a codice Shor a 9 qubit In questo modo, l\u0026rsquo;azione risultante del circuito sugli stati base dei qubit originali è la seguente: $$ \\begin{aligned} \\ket{0} \u0026amp;\\mapsto \\frac{1}{2\\sqrt{2}}(\\ket{000}+\\ket{111})\\otimes(\\ket{000}+\\ket{111})\\otimes(\\ket{000}+\\ket{111}) \\cr \\ket{1} \u0026amp;\\mapsto \\frac{1}{2\\sqrt{2}}(\\ket{000}-\\ket{111})\\otimes(\\ket{000}-\\ket{111})\\otimes(\\ket{000}-\\ket{111}). \\end{aligned} $$\nPropagazione degli errori e operazioni delle porte CNOT # Ora, prima di vedere come gli errori influenzano la nostra codifica, dobbiamo fermarci e introdurre alcune importanti relazioni ed equivalenze riguardanti gli errori $X$ e $Z$. Le seguenti equivalenze possono essere verificate calcolando le moltiplicazioni di matrici o scrivendo le tabelle della verità per porte X e porte Z con il CNOT.\nRelazioni tra porte X e porte CNOT Relazioni tra porte Z e porte CNOT Correzione degli errori di inversione di bit # Considerando un errore di inversione di bit che interessa il nostro circuito, possiamo concentrarci su ciascuno dei tre blocchi separatamente. È facile vedere che ognuno di essi è la codifica di un singolo qubit utilizzando il codice di ripetizione per gli errori di inversione di bit, quindi sfruttando due qubit ancilla per blocco possiamo misurare e correggere fino a un errore di inversione di bit in ogni blocco.\nCorrezione degli errori di inversione di fase # Poiché il codice progettato per correggere le inversioni di fase non è direttamente influenzato dagli errori, mostrare le capacità del codice Shor di rilevare anche questo tipo di errori sarà più difficile dato il nostro ordine di codifica.\nSupponendo che un errore $Z$ interessi uno dei 9 qubit, possiamo usare le equivalenze introdotte in precedenza per dimostrare che è equivalente a un errore di inversione di fase verificatosi prima della codifica interna, come mostrato sotto.\nEquivalenza dell\u0026rsquo;errore di inversione di fase nel codice Shor Quindi un errore $Z$ che si verifica in uno qualsiasi dei tre qubit all\u0026rsquo;interno di un blocco ha lo stesso effetto sullo stato finale di un errore $Z$ che si verifica prima del codice interno.\nQuello che possiamo fare per gestire gli errori di inversione di fase è modellare l\u0026rsquo;errore $Z$ come se si verificasse prima del codice interno; quindi decodificare quest\u0026rsquo;ultimo per tornare alla prima fase della codifica. Ora il nostro qubit originale è semplicemente codificato utilizzando il codice di ripetizione per le inversioni di fase. In questo modo, possiamo semplicemente utilizzare due qubit ancilla come in precedenza per verificare la correttezza del nostro stato, e quindi codificare nuovamente ciascuno dei tre qubit con il codice di inversione di bit. La sindrome rileverà il blocco in cui si è verificata l\u0026rsquo;inversione di fase, come mostrato nella prossima figura.\nShor Correct Z Alla fine, è possibile semplificare il circuito precedente utilizzando quattro porte CNOT in meno, come nella figura sotto.\nShor Correct Z Simplified Correzione simultanea degli errori di bit e di inversione di fase # Abbiamo appena visto come sia gli errori $X$ che $Z$ possano essere rilevati e corretti utilizzando il codice Shor. Consideriamo ora lo scenario in cui si verificano simultaneamente sia un errore di inversione di bit che un errore di inversione di fase, possibilmente sullo stesso qubit; vedremo che il codice Shor è in grado di gestire questo scenario senza ulteriori modifiche.\nPoiché le matrici degli errori $X$ e $Z$ sono anticommutabili: $$ XZ = \\begin{pmatrix}0\u0026amp;1\\cr1\u0026amp;0\\end{pmatrix} \\begin{pmatrix}1\u0026amp;0\\cr0\u0026amp;-1\\end{pmatrix}= \\begin{pmatrix}0\u0026amp;-1\\cr1\u0026amp;0\\end{pmatrix}=-\\begin{pmatrix}1\u0026amp;0\\cr0\u0026amp;-1\\end{pmatrix}\\begin{pmatrix}0\u0026amp;1\\cr1\u0026amp;0\\end{pmatrix}=-ZX $$ invertendole si ottiene solo un fattore di fase globale irrilevante di $-1$. Quindi, indipendentemente dall\u0026rsquo;ordine in cui si verificano gli errori, siamo sempre in grado di propagare l\u0026rsquo;errore $Z$ fino a prima del codice interno. A questo punto è importante notare che le procedure per rilevare ed eventualmente correggere gli errori di inversione di bit e di fase possono essere eseguite indipendentemente introducendo un numero sufficiente di qubit ancillari, quindi possiamo semplicemente applicare prima la procedura per rilevare l\u0026rsquo;errore $X$ e poi quella per rilevare l\u0026rsquo;errore $Z$ per ripristinare infine lo stato iniziale corretto. Per essere precisi, l\u0026rsquo;ordine in cui vengono eseguite le procedure non è affatto importante, poiché le porte $X$ su uno qualsiasi dei nove qubit della codifica commutano con tutte le porte del circuito semplificato per correggere gli errori di inversione di fase (Figura precedente); quindi anche invertendo l\u0026rsquo;ordine delle procedure entrambi gli errori verranno rilevati correttamente.\nRobustezza contro gli errori casuali # Prima di considerare gli errori quantistici arbitrari, analizziamo le prestazioni del codice Shor a 9 qubit quando si verificano errori casuali rappresentati da matrici di Pauli sui qubit.\nConsideriamo un semplice modello di rumore in cui gli errori colpiscono i qubit indipendentemente con probabilità p, analogamente al canale binario simmetrico nei sistemi classici. Per semplicità, ipotizziamo che non ci siano correlazioni tra gli errori. Sebbene probabilità distinte possano essere assegnate agli errori X, Y e Z, ci concentriamo sullo scenario peggiore per il codice Shor: gli errori Y. Poiché gli errori Y equivalgono a errori simultanei X e Z a meno di un fattore di fase globale, essi rappresentano sia errori di inversione di bit che di fase.\nSupponiamo di codificare un qubit logico utilizzando il codice Shor: l\u0026rsquo;esistenza di un vantaggio dipende dalla probabilità di errore p. Analogamente al classico codice a ripetizione a 3 bit, che diventa svantaggioso quando p\u0026gt;1/2, anche per il codice Shor possiamo trovare tale soglia e quantificarne le prestazioni.\nIl codice Shor a 9 qubit è in grado di correggere qualsiasi errore di Pauli su un singolo qubit, inclusi gli errori $Y$, ma fallisce se si verificano più errori $Y$ su qubit diversi. Poiché nel nostro scenario ci concentriamo sugli errori $Y$, il codice è affidabile e protegge il nostro qubit logico finché al massimo uno dei qubit fisici è affetto da un errore, il che si verifica con probabilità $$ (1-p)^9 + 9p(1-p)^8. $$ Altrimenti, il codice fallisce con probabilità $$ 1-(1-p)^9-9p(1-p)^8. $$\nNon è certo che il verificarsi di più errori di Pauli porti a una decodifica errata dello stato originale del qubit, ma ai fini di questa analisi consideriamo questo scenario come un fallimento. Diciamo che in questo caso un errore logico ha interessato il nostro qubit logico. D\u0026rsquo;altra parte, se non utilizziamo il codice, il nostro singolo qubit fisico subisce errori logici con probabilità $p$, quindi il codice offre un vantaggio reale solo per $p$ tale che $$ 1-(1-p)^9-9p(1-p)^8\u0026lt;p. $$\nSoglia di prestazioni Shor Come possiamo vedere nella figura sopra, la soglia per il codice Shor a 9 qubit è di circa $0,0323$. Se $p$ è inferiore al valore precedente, il codice è utile, riducendo la probabilità che si verifichi un errore, ma se $p$ è maggiore della soglia, non dovremmo utilizzarlo poiché peggiorerebbe la robustezza al rumore del nostro sistema rispetto a un singolo qubit fisico.\nDiscretizzazione degli errori nei sistemi quantistici # Il codice Shor a 9 qubit corregge errori quantistici arbitrari, non solo errori $X$ o $Z$, sfruttando la sua capacità di correggere separatamente gli errori $X$ e $Z$. Questo funziona perché qualsiasi possibile errore a singolo qubit può essere scomposto in una combinazione di $X$, $Z$ o entrambi (una proprietà nota come discretizzazione degli errori). Poiché il codice rileva e corregge gli errori $X$ e $Z$ in modo indipendente, gestisce intrinsecamente anche tutti gli altri errori. Pertanto, non sono necessari meccanismi aggiuntivi: correggere $X$ e $Z$ è sufficiente per proteggere dal rumore quantistico arbitrario. Innanzitutto, ci concentriamo sugli errori unitari.\nModellazione degli errori unitari dei qubit # Il codice Shor a 9 qubit può correggere qualsiasi errore unitario a singolo qubit, anche quelli che non sono prossimi all\u0026rsquo;identità (ad esempio, piccole rotazioni o operazioni unitarie arbitrarie). Sebbene possa sembrare difficile correggere un numero infinito di possibili errori, l\u0026rsquo;intuizione chiave è che qualsiasi operatore unitario $U$ a singolo qubit può essere scomposto in una combinazione lineare di operatori di Pauli: $$ U = α I + β X + γ Y + δ Z $$ dove $Y = iXZ$.\nQuando si verifica un errore $U_k$ sul $k$-esimo qubit, lo stato corrotto diventa una sovrapposizione dello stato originale e degli stati con errori $X_k$, $Z_k$ o $X_kZ_k$. Durante il rilevamento dell\u0026rsquo;errore, le misurazioni della sindrome collassano probabilisticamente questa sovrapposizione in uno dei casi di errore di Pauli (o nel caso nessun errore), con le relative probabilità $|\\alpha|^2$, $|\\beta|^2$, $|\\gamma|^2$ e $|\\delta|^2$. La sindrome rivela quale errore si è verificato, consentendone la correzione. Sorprendentemente, questo processo funziona anche per errori minuscoli, poiché le misurazioni della sindrome discretizzano l\u0026rsquo;errore in un\u0026rsquo;operazione di Pauli, che il codice è progettato per correggere. Dopo la correzione, il sistema torna allo stato codificato originale, rimuovendo di fatto l\u0026rsquo;entropia introdotta dall\u0026rsquo;errore. Questo dimostra la discretizzazione degli errori: errori unitari arbitrari vengono ridotti a errori di Pauli correggibili attraverso la misurazione della sindrome.\nIl codice Shor a 9 qubit corregge errori unitari arbitrari attraverso la discretizzazione degli errori. Per gli errori multi-qubit, rappresentiamo formalmente le operazioni utilizzando prodotti tensoriali con matrici identità. Utilizzando la numerazione dei qubit di Qiskit $(Q_8,Q_7,\u0026hellip;,Q_0)$, le operazioni a singolo qubit si estendono allo spazio a 9 qubit come:\n$$ \\begin{aligned} X_0 \u0026amp;= I^{\\otimes 8} \\otimes X = I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes X\\cr Z_4 \u0026amp;= I^{\\otimes 4} \\otimes Z \\otimes I^{\\otimes 4}=I\\otimes I\\otimes I\\otimes I\\otimes Z \\otimes I\\otimes I\\otimes I\\otimes I \\cr U_7 \u0026amp;= I \\otimes U \\otimes I^{\\otimes 7} =I\\otimes U\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I\\otimes I \\end{aligned} $$\ndove $I^{\\otimes n}$ denota un prodotto tensoriale di $n$ matrici identità. Un errore unitario arbitrario $U_k$ sul qubit $k$ si scompone in operatori di Pauli come: $$ U_k = \\alpha I^{\\otimes 9} + \\beta X_k + \\gamma Y_k + \\delta Z_k $$\ncon $X_k$, $Z_k$ definiti in modo simile alle precedenti definizioni di operatori e $Y_k = iX_kZ_k$. Per errori multipli, il formalismo si estende naturalmente: $$ U_{j,k} = (I^{\\otimes (8-j)} \\otimes U_j \\otimes I^{\\otimes j}) \\cdot (I^{\\otimes (8-k)} \\otimes U_k \\otimes I^{\\otimes k}) $$\nLa misurazione della sindrome proietta questi errori continui su operatori di Pauli discreti. Ad esempio, un errore a due qubit $U_{2,5}$ collasserebbe in uno tra $I$, $X_2$, $Z_5$, $X_2Z_5$, ecc., con probabilità determinate dai coefficienti di decomposizione. La struttura del prodotto tensoriale garantisce la corretta identificazione dei qubit interessati attraverso il pattern della sindrome. $$ \\xi \\otimes \\ket{\\psi}\\bra{\\psi} $$ dove $$ \\begin{aligned} \\xi \u0026amp;= |\\alpha|^2 \\ket{I \\text{ sindrome}}\\bra{I \\text{ sindrome}}\\cr \u0026amp;+ |\\beta|^2 \\ket{X_k \\text{ sindrome}}\\bra{X_k \\text{ sindrome}}\\cr \u0026amp;+ |\\gamma|^2 \\ket{X_kZ_k \\text{ sindrome}}\\bra{X_kZ_k \\text{ sindrome}}\\cr \u0026amp;+ |\\delta|^2 \\ket{Z_k \\text{ sindrome}}\\bra{Z_k \\text{ sindrome}}. \\end{aligned} $$\nErrori arbitrari generali sui qubit # Ora esaminiamo gli errori arbitrari (non necessariamente unitari) sui qubit. Nello specifico, modelliamo l\u0026rsquo;errore utilizzando un canale quantistico generico $\\Phi$, che potrebbe rappresentare vari processi di rumore, come sfasamento, depolarizzazione, operazioni di reset o persino canali non convenzionali e meno studiati.\nPer analizzare $\\Phi$, lo esprimiamo innanzitutto in termini di operatori di Kraus: $$ \\Phi(\\sigma) = \\sum_j A_j \\sigma A_j^\\dagger, $$ dove ogni $A_j$ è una matrice $2 \\times 2$. Poiché le matrici di Pauli costituiscono una base per tali operatori, espandiamo ogni $A_j$ come: $$ A_j = \\alpha_j I + \\beta_j X + \\gamma_j Y + \\delta_j Z. $$ Questa decomposizione ci permette di riscrivere l\u0026rsquo;azione di $\\Phi$ su un qubit target $k$ in termini di errori di Pauli: $$ \\begin{aligned} \\Phi_k \\big( \\ket{\\psi}\\bra{\\psi} \\big) \u0026amp;= \\sum_j \\big( \\alpha_j I_k + \\beta_j X_k + \\gamma_j Y_k + \\delta_j Z_k \\big) \\ket{\\psi}\\bra{\\psi} \\cr \u0026amp;\\quad \\times \\big( \\alpha_j I_k + \\beta_j X_k + \\gamma_j Y_k + \\delta_j Z_k \\big)^\\dagger. \\end{aligned} $$ In sostanza, abbiamo riformulato gli operatori di Kraus come combinazioni lineari di operatori di Pauli.\nMisurando la sindrome di errore e applicando la correzione appropriata, lo stato risultante assomiglia al caso di errore unitario, sebbene con una miscela più complessa: $$ \\xi \\otimes \\ket{\\psi}\\bra{\\psi}, $$ dove $\\xi$ ora incorpora i contributi di tutti i termini di Kraus: $$ \\begin{aligned} \\xi \u0026amp;= \\sum_j \\Big( |\\alpha_j|^2 \\ket{I \\text{ sindrome}}\\bra{I \\text{ sindrome}} \\cr \u0026amp;\\quad + |\\beta_j|^2 \\ket{X_k \\text{ sindrome}}\\bra{X_k \\text{ sindrome}} \\cr \u0026amp;\\quad + |\\gamma_j|^2 \\ket{X_kZ_k \\text{ sindrome}}\\bra{X_kZ_k \\text{ sindrome}} \\cr \u0026amp;\\quad + |\\delta_j|^2 \\ket{Z_k \\text{ sindrome}}\\bra{Z_k \\text{ sindrome}} \\Big). \\end{aligned} $$\nSebbene la derivazione esplicita coinvolga più termini, il principio di base rimane identico allo scenario unitario: l\u0026rsquo;estrazione e la correzione della sindrome proiettano l\u0026rsquo;errore in componenti di Pauli distinguibili.\nEstensioni e generalizzazioni # La discretizzazione degli errori si estende naturalmente a codici di correzione degli errori quantistici più generali, inclusi quelli in grado di rilevare e correggere errori su più qubit. In tali scenari, gli errori multi-qubit possono essere rappresentati come prodotti tensoriali di matrici di Pauli: $$ E = \\bigotimes_{k=1}^n P_k \\quad \\text{dove} \\quad P_k \\in {I, X, Y, Z}, $$ e sindromi distinte identificano le corrispondenti correzioni di Pauli che potrebbero dover essere applicate simultaneamente a più qubit, anziché a un singolo qubit.\nAttraverso la misurazione delle sindromi, gli errori vengono effettivamente proiettati su un insieme discreto di possibilità caratterizzate da questi prodotti tensoriali di Pauli. Applicando le correzioni appropriate, possiamo ripristinare lo stato codificato originale. La casualità introdotta durante questo processo è limitata ai qubit delle sindromi, che vengono successivamente scartati o ripristinati. Questo meccanismo rimuove efficacemente la casualità generata dal sistema contenente le informazioni codificate, preservando l\u0026rsquo;integrità del calcolo quantistico.\nIl principio fondamentale rimane coerente con il caso a singolo qubit: la correzione degli errori procede attraverso:\nIdentificazione delle sindromi di errore tramite misurazione;\nDeterminazione delle corrispondenti correzioni di Pauli;\nIsolamento della casualità nei qubit ausiliari che vengono poi rimossi dal sistema.\nQuesto approccio mantiene le caratteristiche essenziali della correzione degli errori quantistica, pur consentendo la scalabilità verso modelli di errore multi-qubit più complessi.\nReferenze # IBM Quantum Learning \u0026ldquo;Correcting quantum errors\u0026rdquo;.\n","date":"17 maggio 2025","externalUrl":null,"permalink":"/articles/correzione-degli-errori-quantistici/","section":"Articoli","summary":"Utilizzando tecniche come i codici di ripetizione e il codice Shor a 9 qubit, la correzione degli errori quantistici consente un calcolo quantistico affidabile proteggendo i qubit da errori di inversione di bit, di fase ed errori arbitrari.","title":"Correzione Degli Errori Quantistici","type":"articles"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/articles/","section":"Articoli","summary":"","title":"Articoli","type":"articles"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/","section":"Autori","summary":"","title":"Autori","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/edoardo-frulla/","section":"Autori","summary":"","title":"Edoardo Frulla","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/leonardo-niccolai/","section":"Autori","summary":"","title":"Leonardo Niccolai","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/mattia-corrado-plac%C3%AC/","section":"Autori","summary":"","title":"Mattia Corrado Placì","type":"authors"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/tags/qec/","section":"Tags","summary":"","title":"QEC","type":"tags"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/tags/qiskit/","section":"Tags","summary":"","title":"Qiskit","type":"tags"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"17 maggio 2025","externalUrl":null,"permalink":"/authors/walid-bou-ezz/","section":"Autori","summary":"","title":"Walid Bou Ezz","type":"authors"},{"content":"","date":"16 maggio 2025","externalUrl":null,"permalink":"/authors/giacomo-bertelli/","section":"Autori","summary":"","title":"Giacomo Bertelli","type":"authors"},{"content":"","date":"16 maggio 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/authors/enrico-pavese/","section":"Autori","summary":"","title":"Enrico Pavese","type":"authors"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/authors/francesco-zanti/","section":"Autori","summary":"","title":"Francesco Zanti","type":"authors"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/authors/marc-helou/","section":"Autori","summary":"","title":"Marc Helou","type":"authors"},{"content":" Introduzione # In questa prima lezione, noi della divisione Hardware vi spiegheremo i primi concetti teorici alla base del funzionamento dei computer quantistici superconduttori. L\u0026rsquo;articolo è diviso in tre sezioni:\nnella prima, ci sarà una breve discussione sui concetti fondamentali della superconduttività; nella seconda, vi spiegheremo come codificare le informazioni utilizzando la superconduttività; infine, parleremo di come poter manipolare queste informazioni. Siete pronti? Iniziamo!\nFondamenti teorici della superconduttività # Nella ricerca di tecnologie di computer quantistici, i circuiti superconduttori sono emersi come una delle piattaforme più promettenti. Tra le varie architetture di qubit superconduttori, il qubit transmon si distingue per il suo equilibrio tra coerenza e scalabilità. Alla base di questo progetto c\u0026rsquo;è il fenomeno della superconduttività, uno stato quantistico macroscopico che permette la creazione di elementi circuitali come le giunzioni Josephson, componenti essenziali per le operazioni transmon. Per comprendere appieno i principi alla base dei qubit transmon, occorre innanzitutto capire la fisica fondamentale della superconduttività.\nSuperconduttività # Conduzione senza perdite ed effetto Meissner # La superconduttività è uno stato in cui un materiale presenta una resistenza elettrica nulla al di sotto di una temperatura critica $T_c$. Questa conduzione senza perdite non è semplicemente un\u0026rsquo;estensione della conduttività ideale, ma piuttosto una manifestazione di una nuova fase quantistica della materia. Inoltre, i superconduttori espellono i campi magnetici dal loro interno (effetto Meissner), una caratteristica distintiva che li differenzia dai conduttori perfetti.\nQuantità critiche # Un materiale superconduttore passa allo stato normale (resistivo) quando è sottoposto a:\nTemperature superiori a $T_c$ Campi magnetici superiori al campo magnetico critico $H_c (T)$ Correnti superiori a una corrente critica $I_c$ La dipendenza dalla temperatura del campo critico è data dalla legge empirica:\n$$ \\begin{aligned} H = H_{c_0} \\cdot \\left(1 - \\left(\\frac{T}{T_{c}}\\right)^2 \\right) \\end{aligned} $$\ne secondo la legge di Ampère, questo campo critico è correlato alla massima corrente sostenibile dal materiale, che è: $I_c = 2 \\pi R H_c$\nPortatori di carica nei superconduttori # Nello stato superconduttivo, gli elettroni di conduzione formano coppie legate note come coppie di Cooper, che si comportano come bosoni. I meccanismi di accoppiamento sono diversi, in questa sede ci occuperemo per semplicità dell\u0026rsquo;accoppiamento fonico, il più semplice - nondimeno l\u0026rsquo;unico analiticamente descritto dalla teoria BCS. Funziona così: quando un elettrone si muove nel reticolo, lo distorce a causa dell\u0026rsquo;attrazione coulombiana con gli ioni del reticolo, creando un potenziale positivo locale che attrae un altro elettrone.\nPoiché queste coppie hanno spin intero, non seguono il principio di esclusione di Pauli e possono condensarsi in un singolo stato quantistico, portando alla coerenza macroscopica della fase superconduttiva.\nFunzione d\u0026rsquo;onda macroscopica # Ogni coppia di Cooper contribuisce a uno stato quantico collettivo descritto da una funzione d\u0026rsquo;onda macroscopica:\n$\\Psi(r, t) = \\Psi_0 \\cdot e^{-j(\\omega t + \\phi)}$\nQuesta funzione d\u0026rsquo;onda viene estesa all\u0026rsquo;intero superconduttore e la sua fase $\\phi$ diventa un elemento chiave nella dinamica dei circuiti superconduttori, poiché è legata al campo magnetico esterno che agisce sulla giunzione, come vedremo tra poco.\nGiunzione Josephson ed effetto Josephson # Una giunzione Josephson (JJ) è costituita da due superconduttori separati da un sottile strato isolante. A causa dell\u0026rsquo;effetto tunnel della funzione d\u0026rsquo;onda macroscopica, una supercorrente può fluire attraverso questo isolante, un fenomeno noto come effetto Josephson.\nÈ importante notare che non sono le singole coppie di Cooper, ma le funzioni d\u0026rsquo;onda macroscopiche a interferire e a consentire la corrente: $ I = I_c \\cdot \\sin(\\phi) $\nDove $\\phi = \\phi_2 - \\phi_1$ è la differenza di fase attraverso la giunzione, riferita alla fase delle due funzioni d\u0026rsquo;onda definite rispettivamente per i due lati superconduttori della JJ.\nQuesta relazione non lineare è responsabile del comportamento della JJ come induttore non lineare, con un\u0026rsquo;induttanza effettiva:\n$$ \\begin{aligned} L(\\phi) = \\frac{\\Phi_0}{2 \\pi I_c \\cos(\\phi)} \\end{aligned} $$\ncon\n$L_j = (\\Phi_0)/(2 \\pi I_c)$\ndefinita come induttanza di Josephson\n$\\Phi_0 = \\frac{h}{2e} \\approx 2,07 \\times 10^{-15} Wb$ è il quanto di flusso magnetico, cioè una costante che si riferisce ai più piccoli quanti di flusso magnetico che possiamo considerare.\nConsiderazioni sull\u0026rsquo;energia # La giunzione Josephson immagazzina energia come: $E(\\phi) = E_J \\cdot (1 - \\cos(\\phi))$\nDove: $E_J = \\frac{I_c \\Phi_0}{2 \\pi}$ è la energia Josephson. Questo valore è periodico rispetto alla differenza di fase definita sopra e può essere regolato da un campo magnetico esterno che agisce sulla JJ, come vedremo tra poco.\nRelazioni tensione-fase e flusso # Dalla relazione tra la tensione $V$ e la differenza di fase $\\phi$:\n$(d \\phi)/(d t) = (2 \\pi V)/(\\Phi_0) $\npossiamo definire la quantità di flusso elettrico $\\Phi$ come:\n$ \\Phi = \\int_0^t V(t\u0026rsquo;) d t\u0026rsquo; = \\frac{\\Phi_0}{2 \\pi}(\\phi - \\phi_0) $\nda cui possiamo esprimere $\\phi= 2\\pi \\Phi/(\\Phi_0) + \\phi_0$\nCiò rende la differenza di fase direttamente legata al flusso totale che agisce sulla JJ.\nQubit a superconduttore: dal Circuito LC al Transmon Qubit # Dopo aver dato uno sguardo alla fisica della superconduttività, vediamo come utilizzarla per costruire un\u0026rsquo;unità di informazione quantistica. Partendo da circuiti classici, costruiremo strutture in cui le coppie di Cooper sono utilizzate come portatrici di informazione grazie alla loro presenza.\nReview del Qubit # Cominceremo con un ripasso della basilare unità di informazione quantistica, il quantum bit o qubit. Nella teoria classica dell\u0026rsquo;informazione, l\u0026rsquo;unità di misura più elementare è il binary digit, o bit, che può assumere uno dei due valori 0 o 1. La sua controparte quantistica è il qubit che, grazie alla superposizione degli stati, un semplice risultato della matematica fondante della meccanica quantistica, può assumere valori pari a tutte le infinite combinazioni di 0 e 1. Fisicamente, un qubit è un sistema a due livelli che può essere manipolato e letto in modo diverso a seconda della tecnologia usata per implementarlo. Utilizzando la notazione di Dirac, possiamo definire un qubit come:\n$$ \\begin{aligned} \\Psi = \\alpha\\ket{0} + \\beta\\ket{1} \\end{aligned} $$\nDove $\\alpha$ e $\\beta$ sono numeri complessi che devono soddisfare la relazione:\n$|\\alpha|^2 + |\\beta|^2 = 1 $\nCircuiti LC e linee di trasmissione # Avendo in mente l\u0026rsquo;obbiettivo di costruire un qubit con circuiti superconduttori, cominceremo a studiare un circuito elettrico fondamentale che è alla base sia del qubit stesso sia del suo sistema di manipolazione.\nCircuito LC # Questo semplice circuito LC è costituito da un parallelo di un induttore e di un condensatore. Agisce come un risonatore che immagazzina energia oscillando alla sua frequenza di risonanza. L\u0026rsquo;energia è divisa tra la carica all\u0026rsquo;interno del condensatore e il campo magnetico formato all\u0026rsquo;interno dell\u0026rsquo;induttore dalla corrente passante e può essere descritta dalla seguente Hamiltoniana:\n$$ \\begin{aligned} H = \\frac{Q^2}{2C} + \\frac{\\Phi^2}{2L} \\end{aligned} $$\nA causa della forma quadratica dell\u0026rsquo;energia, il potenziale all\u0026rsquo;interno di tale circuito è parabolico.\nApplicando quindi la quantizzazione del circuito si ottiene l\u0026rsquo;Hamiltoniana dell\u0026rsquo;oscillatore armonico quantistico con energie accessibili discrete derivanti dal profilo del potenziale. L\u0026rsquo;Hamiltoniana dell\u0026rsquo;oscillatore armonico quantistico può essere riscritta attraverso il formalismo degli operatori di creazione e annichilazione come:\n$\\hat{H} = \\hbar w_r ( \\hat{a} ^ \\dagger \\hat{a} + \\frac{1}{2})$\nSi noti che l\u0026rsquo;armonicità fa sì che i salti di energia siano tutti pari a $\\hbar w_r$ con $w_r = \\frac{1}{\\sqrt{L C}}$ uguale alla frequenza di risonanza del circuito.\nLinea di trasmissione # La linea di trasmissione è un modello di circuito che trasporta energia elettromagnetica senza perdite significative. Può essere schematizzata come un modello a elementi concetrati composto da un array di circuiti LC accoppiati. Cortocircuitando entrambe le estremità della linea di trasmissione verso massa si ottiene un vero e proprio risonatore in cui i vettori d\u0026rsquo;onda ammessi sono discretizzati come:\n$k = {2 \\pi n}/L$\ncon L uguale alla lunghezza del risonatore e $n = 1, 2, 3\u0026hellip;$\nL\u0026rsquo;Hamiltoniana può essere nuovamente scritta in termini di operatori di creazione e annichilazione che creano e distruggono un\u0026rsquo;onda con vettore d\u0026rsquo;onda $k$:\n$$ \\begin{aligned} \\hat{H} = \\sum_{n=0} \\hbar w_n [\\hat{a}(w_n)^ \\dagger \\hat{a}(w_n)] \\end{aligned} $$\ncon $w_n = (n + 1)w_r$ tali le frequenze dei modi ammessi. Il concetto di linea di trasmissione come risonatore tornerà utile nelle parti successive, quando verrà utilizzato per leggere lo stato del qubit mediante accoppiamento capacitivo.\nQubit a superconduttore # Utilizzando i concetti illustrati sopra, passiamo ora alla costruzione di un qubit a superconduttore. A tal fine dovremo fondere concetti elettronici classici come il circuito LC con un po\u0026rsquo; di magia superconduttiva.\nAtomi artificiali # Quando si utilizza una tecnologia per realizzare un qubit, è necessario tenere presente il comportamento che vogliamo che questo abbia. Il concetto di atomi artificiali è il modello che descrive con precisione le caratteristiche desiderate del qubit. In pratica vogliamo che il nostro sistema fisico si comporti come un atomo naturale, con i suoi salti di energia disomogenei e discreti che possono essere controllati inviando accuratamente dei segnali e allo stesso modo essere facilmente letti. Vorremmo quindi dche il sistema abbia livelli energetici discreti e transizioni anarmoniche tra di essi in modo che ciascun salto energetico possa essere controllato indipendentemente tramite segnali con uguale energia.\nNel caso dei qubit come atomi artificiali, vorremmo che i portatori di informazione, nel nostro caso le coppie di Cooper, mantenessero l\u0026rsquo;informazione per lunghi tempi, che in questo quadro equivale a dire tempi di coerenza. È inoltre fondamentale evitare fluttuazioni termiche con energia superiore alla transizione in esame, in modo da evitare eccitazioni indesiderate dei portatori. Infine, il rischio maggiore di decoerenza dovuto alle influenze ambientali deve essere adeguatamente contenuto.\nQubiti di carica # Prendiamo ora il circuito LC descritto sopra e sostituiamo l\u0026rsquo;induttore lineare con una giunzione Josephson. Quello che otterremo è la prima forma di qubit a superconduttore che possiamo considerare, chiamato anche qubit di carica.\nIl condensatore orizzontale che collega il generatore con la giunzione simboleggia l\u0026rsquo;accoppiamento capacitivo del qubit a una sorgente di tensione arbitraria. Il qubit di carica è costituito semplicemente da una giunzione Josephson in parallelo ad un condensatore. La differenza fondamentale rispetto a un normale circuito LC è il comportamento non lineare della giunzione. La caratteristica sinusoidale della sua corrente dà origine a un profilo anarmonico del potenziale:\n$$ \\begin{aligned} \\hat{H} = 4E_c \\hat{n}^2 - E_j cos(\\phi) \\end{aligned} $$\ndove $\\hat{n}$ è l\u0026rsquo;operatore numero che è direttamente collegato agli operatori di creazione e annichilazione e rappresenta il numero di coppie di Cooper all\u0026rsquo;interno del circuito, $E_c$ è l\u0026rsquo;energia di carica con una proporzionalità inversa rispetto alla capacità del condensatore e $E_j$ è l\u0026rsquo;energia Josephson mentre $\\phi$ è la differenza di fase della funzione d\u0026rsquo;onda macroscopica attraverso la giunzione.\nIl comportamento quadratico dell\u0026rsquo;energia risiede ora interamente nell\u0026rsquo;operatore numero, mentre il potenziale non lineare della giunzione dà luogo a salti anarmonici all\u0026rsquo;interno del suo profilo.\nGrazie all\u0026rsquo;anarmonicità del potenziale, le transizioni energetiche discrete accessibili in chiave quantistica sono ora disomogenee e consentono di controllare due stati in modo indipendente.\nRegime transmonico # Storicamente, le prime implementazioni del qubit a superconduttore erano qubit di carica, in cui l\u0026rsquo;informazione era codificata nella quantità di coppie di Cooper all\u0026rsquo;interno del circuito. La principale fonte di rumore che degrada tali sistemi è il rumore di carica, dovuto alle cariche in prossimità del circuito spinte dal generatore di tensione che il qubit percepisce, modellabile come una fluttuazione parametrica ($n_g$) del numero di portatori nell\u0026rsquo;Hamiltoniana: $$ \\begin{aligned} \\hat{H} = 4E_c (\\hat{n}^2-n_g^2) - E_j cos(\\phi) \\end{aligned} $$ la fluttuazione potrebbe anche cambiare nel tempo. La principale conseguenza del rumore di carica è la costante variazione delle frequenze di transizione del sistema rendendo quasi impossibile il controllo del qubit.\nPer attenuare l\u0026rsquo;influenza di questo tipo di rumore, il contributo dell\u0026rsquo;energia Josephson nell\u0026rsquo;Hamiltoniana deve superare quello dell\u0026rsquo;energia di carica. L\u0026rsquo;implementazione di un dispositivo di interferenza quantistica a superconduttore (SQUID) per controllare $E_j$ o l\u0026rsquo;aumentare dell\u0026rsquo;area del condensatore per ridurre $E_c$ sono valide alternative per manipolare il rapporto $E_j/E_c$.\nL\u0026rsquo;immagine sovrastante mostra il rapporto tra i livelli energetici con l\u0026rsquo;energia dello stato fondamentale in funzione della carica di rumore. È evidente che con bassi valori di $E_j/E_c$ piccole variazioni di $n_g$ portano a cambiamenti deleteri nelle transizioni energetiche. Quando $E_j/E_c$ è nell\u0026rsquo;intervallo $20-80$ si dice che il qubit è in regime transmonico e la sensibilità alle fluttuazioni di carica è quasi completamente soppressa. Si noti anche che l\u0026rsquo;anarmonicità nelle transizioni si riduce con valori più alti di $E_j/E_c$, ma decade più lentamente dell\u0026rsquo;influenza della fluttuazione di carica, cosicché il qubit è ancora considerabile come un oscillatore quantistico anarmonico.\nEssendo in regime transmonico, trascurando quindi il termine di carica di rumore nell\u0026rsquo;Hamiltoniana ed esprimendo l\u0026rsquo;energia con gli operatori di creazione e annichilazione, si trova questa forma finale:\n$hat{H} = \\hbar w_q \\hat{b} ^ \\dagger \\hat{b} - E_c/\\hat{b}^ \\dagger \\hat{b} ^\\dagger \\hat{b}\\hat{b}$\ndove $\\hbar w_q = \\sqrt{8 E_c E_j} - E_c$ è la frequenza corretta del trasmone e si riferisce alla prima transizione di energia nello spettro.\nImplementazione tecnologica # Il modello Jaynes - Cummings # Ora che abbiamo costruito il nostro atomo, ci sono alcuni problemi importanti da risolvere: come possiamo controllare lo stato quantistico senza perturbarlo? Come misurarlo invece? Prima di parlarne, dobbiamo fare un passo indietro, utilizzando un parallelismo per capire meglio il nostro sistema fisico.\nSappiamo che, se trasmettiamo un raggio laser verso un atomo alla giusta frequenza, possiamo eccitare il suo stato, promuovendo l\u0026rsquo;elettrone orbitante a un livello energetico superiore.\nQuesto modello è descritto dall\u0026rsquo; hamiltoniana di Jaynes - Cummings:\n$$ \\begin{aligned} \\hat H_{JC} = \\omega_r \\hat a^\\dagger \\hat a + \\frac{\\omega_{01}}{2} \\hat\\sigma_z + g (\\hat a^\\dagger \\hat\\sigma_- + \\hat a \\hat\\sigma_+) \\end{aligned} $$\nL\u0026rsquo;interazione luce-materia è ben descritta nel terzo elemento:\nla diseccitazione dell\u0026rsquo;atomo porta alla creazione di un fotone “sacrificare” un fotone significa eccitare l\u0026rsquo;atomo Questo controllo a livello atomico può essere ben eseguito all\u0026rsquo;interno di un risonatore ottico. Un risonatore è una struttura in grado di selezionare determinate frequenze d\u0026rsquo;onda per risuonare in un sistema. Prendiamo ad esempio una chitarra: le sue corde emettono determinate note perché ne selezioniamo una certa lunghezza, premendo le corde sulla sua superficie.\nUn esempio noto in fisica è la cavità di Fabry-Perot, utilizzata per la costruzione dei laser: se mettiamo due specchi uno di fronte all\u0026rsquo;altro a una certa distanza, solo poche frequenze di onde elettromagnetiche oscilleranno tra loro. Mettere un atomo all\u0026rsquo;interno della cavità di Febry - Perot ci permette di controllarne lo stato energetico.\nFacciamo lo stesso per il nostro qubit transmon: se lo poniamo all\u0026rsquo;interno di un risonatore fatto di linee di trasmissione superconduttrici, potremo controllarlo e misurarlo.\nPer dimostrare ciò, esaminiamo il circuito equivalente di questo sistema, per ricavarne l\u0026rsquo;hamiltoniana. La tecnica di studiare i sistemi quantistici analizzando il loro circuito equivalente è chiamata elettrodinamica quantistica dei circuiti (QED).\nLa derivazione di questo circuito è semplice:\nil risonatore è rappresentato da un oscillatore armonico (circuito LC) il qubit è rappresentato da un oscillatore anarmonico (circuito JJ + C) L\u0026rsquo;accoppiamento tra i due è rappresentato da una capacità ($C_g$). L\u0026rsquo;hamiltoniana corrispondente a questo circuito è: $$ \\begin{aligned} \\hat H = (\\frac{\\hat Q^2_r}{2C_r} +\\frac{\\hat \\Phi ^2_r}{ 2 L_r}) + (4 E_c \\hat n^2 - E_j cos \\hat \\phi) \\end{aligned} $$\nche, con alcune approssimazioni, è equivalente al modello di Jayes - Cummings.\nQuindi, possiamo controllare l\u0026rsquo;informazione immagazzinata in un qubit con onde elettromagnetiche così come possiamo controllare lo stato energetico di un atomo con un laser!\nIl regime dispersivo # Ora che il nostro modello è pronto per essere utilizzato, c\u0026rsquo;è un problema importante da risolvere: come possiamo modificare lo stato del qubit senza perturbarlo?\nSappiamo dai concetti di base della fisica quantistica che entrare in contatto con un sistema quantistico porta al suo collasso: pertanto dobbiamo trovare un modo per modificare l\u0026rsquo;informazione quantistica e creare un computer utile.\nLa soluzione si ottiene nel regime dispersivo: l\u0026rsquo;idea principale è quella di utilizzare due frequenze diverse, una per il controllo ($\\omega_{01}$) e una per la lettura ($\\omega_r$), in modo da effettuare due operazioni distinte sul qubit.\nSe scegliamo queste due frequenze in modo tale che: $$ \\begin{aligned} \\Delta = | \\omega_{q}-\\omega_r| \u0026raquo; g \\end{aligned} $$\nl\u0026rsquo;hamiltoniana di Jaynes - Cummings può essere approssimata a:\n$$ \\begin{aligned} \\hat H_{disp} = (\\omega_r + \\chi \\hat \\sigma_z) \\hat a^\\dagger \\hat a + \\frac{\\omega_{q}}{2}\\hat \\sigma_z \\end{aligned} $$ con $\\chi \\approx \\frac{g^2}{\\Delta} $.\nCiò ha due conseguenze dirette:\nse l\u0026rsquo;autovalore di $\\sigma_z$ è +1 (il qubit è in uno stato eccitato), la frequenza di risonanza del risonatore diventerà $\\omega_r + \\chi$\nSe l\u0026rsquo;autovalore di $\\sigma_z$ è -1 (il qubit è nel ground state), la frequenza di risonanza del risonatore diventerà $\\omega_r - \\chi$.\nCiò significa che lo stato del qubit influenza il sistema che lo circonda.\nCome si può notare da questa immagine, $\\omega_q$ e $\\omega_r$ sono molto distanti l\u0026rsquo;uno dall\u0026rsquo;altro.\nÈ ora di usare questo sistema!\nmisura: sondare il risonatore alla frequenza di $\\omega_r$; a seconda dello stato del qubit, la frequenza di trasmissione sarà a $\\omega_r + \\chi$ o $\\omega_r - \\chi$. controllo: sondare il risonatore a $\\omega_q$ con la forma d\u0026rsquo;onda necessaria per ruotare lo stato del qubit Controllo del qubit # Ma cosa intendiamo esattamente con “rotazione dello stato del qubit”? Come è possibile farlo con frequenze di risonanza?\nPrima di parlarne, dobbiamo fare un breve riepilogo su un argomento importante nell\u0026rsquo;analisi dei segnali: la modulazione I/Q.\nUn segnale (una forma d\u0026rsquo;onda generica, come una sinusoide) può essere scomposto in due componenti additive:\nun segnale in fase (I), che avrà fase zero un segnale in quadratura (Q), con fase pari a $\\frac{\\pi}{2}$. Un segnale a frequenza fissa può anche essere rappresentato come un punto in un piano complesso, i cui assi indicano le componenti I e Q che lo costituiscono:\nUtilizzando nuovamente la tecnica QED, si ricava l\u0026rsquo;hamiltoniana della tensione di pilotaggio e del sistema di qubit controllati:\n$$ \\begin{aligned} \\hat H_d = \\Omega V_0 s(t) (I \\sigma_x + Q \\sigma_y) \\end{aligned} $$\ndove:\n$\\Omega = \\frac{C_d}{C_\\Sigma} Q_0$ (costante relativa al circuito equivalente) $V_0$ è l\u0026rsquo;ampiezza della tensione generata $s(t)$ è la forma d\u0026rsquo;onda del segnale L\u0026rsquo;idea principale è quella di modulare le componenti I e Q del segnale di pilotaggio per selezionare una rotazione lungo l\u0026rsquo;asse x o y del qubit.\nQuindi, si hanno due casi:\nse Q = 0, si ottiene la rotazione intorno all\u0026rsquo;asse x se I = 0, si ottiene la rotazione intorno all\u0026rsquo;asse y Il caso della rotazione attorno all\u0026rsquo;asse z è diverso; infatti, il gate z è detto \u0026ldquo;virtuale\u0026rdquo;, poiché non possiamo eseguire direttamente una rotazione attorno all\u0026rsquo;asse z, ma solo regolare la fase del segnale per trasformare le sue componenti I e Q:\n$I\u0026rsquo; = I \\cos \\phi - Q \\sin \\phi $\n$Q\u0026rsquo; = I \\sin \\phi - Q \\cos \\phi $\nIn tutti e tre i casi, l\u0026rsquo;angolo di rotazione è legato alla durata del segnale di pilotaggio.\nThat\u0026rsquo;s all, folks! # Con questo articolo vi abbiamo spiegato:\ncos\u0026rsquo;è la superconduttività; cos\u0026rsquo;è un qubit transmon; come manipolare il qubit in un computer quantistico superconduttivo. Se questo articolo ti è piaciuto, condividilo con altri appassionati di Quantum!\n","date":"28 aprile 2025","externalUrl":null,"permalink":"/articles/hardware_superconducting_qubits_08_05_2025_gvpgje/superconducting-qubits/","section":"Articoli","summary":"Introduzione sulla superconduttività, la costruzione di un qubit transmon e il controllo dell\u0026rsquo;informazione in un computer quantistico superconduttivo","title":"Qubit superconduttivi","type":"articles"},{"content":"","date":"28 aprile 2025","externalUrl":null,"permalink":"/tags/superconducting/","section":"Tags","summary":"","title":"Superconducting","type":"tags"},{"content":" Candidatura inviata con successo! Grazie per il tuo interesse nel far parte di QubiTO! Abbiamo ricevuto la tua candidatura e la esamineremo attentamente.\nIl nostro team ti contatterà presto per i prossimi passi del processo di selezione.\nNel frattempo, puoi:\nSeguirci sui nostri social media per rimanere aggiornato Scoprire di più sul nostro team e sui nostri progetti Visitare il nostro sito web per le ultime novità Grazie ancora per il tuo interesse in QubiTO!\n","date":"27 gennaio 2025","externalUrl":null,"permalink":"/thankyou/","section":"Grazie!","summary":"Candidatura inviata con successo!","title":"Grazie!","type":"thankyou"},{"content":" Chi siamo QubiTO nasce nel 2023 sulla scia dell\u0026rsquo;entusiasmo di studenti e professori del Politecnico di Torino verso la fisica quantistica e le sue contemporanee, promettenti prospettive tecnologiche. Insieme, uniti dalla passione per tale dinamismo, ricerchiamo e divulghiamo gli aspetti di questo affascinante mondo nelle sue innumerevoli declinazioni e sfruttiamo le nostre conoscenze e competenze partecipando in squadra ad hackaton internazionali.\nCon l\u0026rsquo;inaugurazione del primo quantum computer del Politecnico Spark IQM inizieremo infine ad applicare il nostro bagaglio di conoscenze teoriche nella realizzazione di progetti pratici!\nIl nostro team è attualmente composto da cinque divisioni che si occupano di approfondimenti interni al team stesso, relativi ad aree tecnologiche definite, per la maggior parte orientate alla computazione quantistica:\nHardware Si occupa del funzionamento pratico del computer quantistico, indagando la varietà di sistemi fisici utilizzati per codificare i bit quantistici \u0026ndash; i qubit \u0026ndash; e i sistemi elettronici impiegati per controllarli. Particolare attenzione è dedicata alla tecnologia superconduttiva, alla base del nuovo computer quantistico del Politecnico Spark IQM\nDecoerenza I sistemi fisici che manifestano proprietà quantistiche sono soggetti ad un naturale rilassamento che ne deteriora le proprietà stesse all\u0026rsquo;avanzare del tempo. Il fenomeno prende il nome di \u0026ldquo;decoerenza\u0026rdquo; e la sua caratterizzazione è di fondamentale importanza per garantire il corretto funzionamento di ogni computer quantistico. La divisione del team dedita allo studion della decoerenza effettua ricerche sui meccanismi disici che concorrono al fenomeno e come limitarlo efficacemente ai fini della computazione quantistica.\nCorrezione errori Laddove la parziale decoerenza del sistema fisico o l\u0026rsquo;interferenza dovuta al rumore dell\u0026rsquo;elettronica di controllo corrompano lo stato del qubit, l\u0026rsquo;implementazione di algoritmi per la correzione degli errori permette di recuperarne il valore originale. L\u0026rsquo;ottimizzazione di tali algoritmi è un aspetto di cruciale importanza, soprattutto nell\u0026rsquo;ottica di funzionamento di computer ancora troppo poco potenti. La divisione che si dedica alla correzione degli errori studia questi algoritmi nelle loro significative differenze rispetto agli analoghi ampiamente utilizzati per i computer classici.\nProgrammazione Le operazioni basilari che vengono eseguite dai qubit prendono il nome di \u0026ldquo;gates\u0026rdquo; e la loro opportuna combinazione rende idealmente possibile eseguire qualunque operazione che sia già alla portata di un computer classico. La vera potenza dei qubit risiede nel fatto che molti dei gates non hanno un corrispettivo classico, permettendo di effettuare computazioni complesse in maniera esponenzialmente più veloce nei casi più fortunati. La divisione di programmazione studia il modo di combinare i gates per ricavare algoritmi quantistici che dimstrino una maggiore rapidità di esecuzione rispetto alla controparte classica.\nMetodi matematici e comunicazione La divisione dedicata ai metodi matematici e alla comunicazione sposta il suo focus dall\u0026rsquo;implementazione del computer quantistico per enfatizzare sia i concetti matematici essenziali per comprendere varie sfide, come i problemi di ottimizzazione, sia l\u0026rsquo;infrastruttura necessaria per il trasferimento di informazioni quantistiche, ossia messaggi codificati in forma di qubit. Oltre all\u0026rsquo;attenzione sulle reti quantistiche e allo studio dell\u0026rsquo;informazione quantistica, questa divisione attribuisce un\u0026rsquo;importanza significativa all\u0026rsquo;esplorazione della crittografia quantistica, una tecnologia promettente per la sicurezza delle comunicazioni riservate.\nDivulgazione Una sesta divisione si occupa della divulgazione esterna al team tramite i canali social di QubiTO, la gestione del sito e la partecipazione ad eventi a contatto con il pubblico, approfondendo anche argomenti e applicazioni della fisica quantistica più distanti dalla computazione quantistica.\nUna sottodivisione di programmatori si occupa inoltre della gestione e del miglioramento del sito.\n","externalUrl":null,"permalink":"/team/","section":"","summary":"Chi siamo QubiTO nasce nel 2023 sulla scia dell\u0026rsquo;entusiasmo di studenti e professori del Politecnico di Torino verso la fisica quantistica e le sue contemporanee, promettenti prospettive tecnologiche.","title":"","type":"page"},{"content":" 🇨🇭 Quantum Hackathon ETH di Zurigo 2025 Sei dei nostri studenti hanno sfidato i loro brillanti colleghi internazionali all\u0026#39;ETH di Zurigo. Divisi in due squadre, hanno affrontato la sfida di \u0026#34;Portfolio Optimization\u0026#34; presentata da QCentroid e quella di \u0026#34;Gate parallelization\u0026#34; proposta da QuEra. Al ritorno a Torino, hanno presentato le loro soluzioni ai colleghi, ai professori e agli appassionati di quantum computing.\n🚀 Salone dell\u0026#39;Orientamento 2025 Seconda partecipazione al Salone dell\u0026#39;Orientamento, incontrando nuovi studenti interessati alla fisica quantistica.\n🔢 Pi Greco Day 2025 Celebrazione del Pi Greco Day con prospettiva quantistica, esplorando il ruolo di π nella fisica teorica e nella meccanica quantistica.\n🇩🇪 Pushquantum Hackathon 2024 Partecipazione all\u0026#39;hackathon internazionale presso il TUM Entrepreneurship Research Institute di Monaco di Baviera.\n🧠 Hackathon interno Autunno 2025 Secondo hackathon interno focalizzato su Quantum Optimisation e Quantum Machine Learning, con progetti originali ed esplorazione di nuovi orizzonti applicativi.\n🎤 DevFestAlps 2024 2024 Seconda partecipazione al Google DevFestAlps con un nuovo talk, condividendo la nostra passione per il quantum computing.\n🌍 ETH Quantum Hackathon 2024 2024 Il nostro primo hackathon internazionale all\u0026#39;ETH di Zurigo. Abbiamo lavorato intensamente per 24 ore su diverse challenge proposte da startup e aziende.\n🎓 Salone dell\u0026#39;Orientamento 2024 2024 Durante l\u0026#39;annuale Salone dell\u0026#39;Orientamento del Politecnico, ci siamo presentati a futuri studenti curiosi e interessati al mondo quantistico.\n✨ Esplorando le Opportunità Quantistiche 2023 Il nostro primo grande evento di divulgazione al Politecnico di Torino in collaborazione con BeQuantum. Un grande successo con oltre 200 partecipanti in sala.\n🎤 DevFestAlps 2023 2023 Sul palco del Google DevFestAlps presso il Toolbox Coworking a Torino, abbiamo presentato il nostro lavoro sull\u0026#39;algoritmo di Grover e gli oracoli quantistici.\nGoogle DevFestAlps 2023 🔍 Hackathon interno Autunno 2023 Il team ha affrontato una sfida interna incentrata sullo sviluppo dell\u0026#39;algoritmo di Grover. I team, composti in modo eterogeneo, hanno lavorato in autonomia e in competizione tra loro, ricreando lo spirito autentico di un hackathon.\n","externalUrl":null,"permalink":"/activities/","section":"Attività","summary":"🇨🇭 Quantum Hackathon ETH di Zurigo 2025 Sei dei nostri studenti hanno sfidato i loro brillanti colleghi internazionali all\u0026#39;ETH di Zurigo.","title":"Attività","type":"page"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categorie","summary":"","title":"Categorie","type":"categories"},{"content":" Mettiti in Contatto con Noi! Siamo felici di accogliere proposte di collaborazione e siamo entusiasti di esplorare potenziali partnership. Se sei interessato a collaborare con noi o hai domande, non esitare a contattarci. Scrivici! I nostri partner Partner principale Seguici Rimani aggiornato sui nostri ultimi progetti ed eventi seguendoci sui social media! Instagram Linkedin Il tuo aiuto è molto importante per noi! Che tu abbia domande, suggerimenti o semplicemente voglia salutarci, il tuo contributo è prezioso per noi. Grazie per essere con noi in questa avventura! ","externalUrl":null,"permalink":"/contacts/","section":"","summary":"Mettiti in Contatto con Noi!","title":"Contatti","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/snippets/","section":"Snippets","summary":"","title":"Snippets","type":"snippets"},{"content":"QubiTO is waiting for you! We are looking for quantum enthusiasts from every department to share in an adventure. If you think of yourself as suitable, fill this form with all the required information. Explain to us why you want to join the team, tell us about your background and what you expect to achieve with your experience in the team.\nBased on the information on this form we will contact you for an interview. Don\u0026rsquo;t worry, it is just to know you better, bring all your passion and confidence with you!\n","externalUrl":null,"permalink":"/join-us/","section":"Unisciti a noi","summary":"QubiTO is waiting for you!","title":"Unisciti a noi","type":"join-us"}]